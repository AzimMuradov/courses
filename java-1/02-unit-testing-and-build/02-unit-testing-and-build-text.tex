\documentclass[a5paper]{article}
\usepackage[a5paper, top=8mm, bottom=8mm, left=8mm, right=8mm]{geometry}

\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}

\usepackage{fontspec}
\setmainfont{FreeSerif}
\newfontfamily{\russianfonttt}[Scale=0.7]{DejaVuSansMono}

\usepackage[font=scriptsize]{caption}

\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{cite}

\usepackage[hang,multiple]{footmisc}
\renewcommand{\footnotelayout}{\raggedright}

\PassOptionsToPackage{hyphens}{url}\usepackage[xetex,linktocpage=true,plainpages=false,pdfpagelabels=false]{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}

\usepackage{tabu}

\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{footnote}
\usepackage{minted}

\sloppy
\pagestyle{plain}

\title{Юнит-тестирование и системы сборки}
\author{Юрий Литвинов\\\small{yurii.litvinov@gmail.com}}

\date{16.01.2019}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Введение}

На этой паре будет быстрая ликвидация безграмотности в области сопутствующих разработке любого сколько-нибудь большого проекта вещей --- модульного тестирования и организации билда. В общем-то, каждая из этих тем заслуживает отдельной пары, но, как я понимаю, вам уже надо приступать к написанию проектов под Android, поэтому расскажу кратко и только то, что нужно, чтобы взять и начать пользоваться. Остальное можно почитать в литературе, по мере использования этих вещей в своих проектах.

\section{Юнит-тестирование}

Во-первых, зачем нужно юнит-тестирование: есть шуточные аксиомы, которые формулируются так:
\begin{itemize}
	\item Любая программа содержит ошибки
	\item Если программа не содержит ошибок, их содержит алгоритм, который реализует эта программа
	\item Если ни программа, ни алгоритм ошибок не содержат, такая программа даром никому не нужна
\end{itemize}

В общем-то, практика показывает, что так оно и есть. Hello world можно написать и без ошибок, однако практическая ценность такой программы сомнительна. А любая достаточно сложная программная система ошибки (баги) в том или ином виде содержит. Надеяться на то, что вы умнее всех, и если будете кодить внимательно и осторожно, сумеете избежать ошибок --- глупо. Даже очень опытные программисты, если просто напишут пару сотен строк кода, они, скорее всего, не будут даже компилиться, не то что уж работать правильно. Помочь обнаружить ошибки и призвано тестирование. То есть, первым барьером на пути ошибок является компилятор --- если в программе написана явная чушь, компилятор это заметит и отругается. Разработчики языков программирования стараются сделать так, чтобы возможно большее количество ошибок обнаруживалось компилятором (или какими-то другими средствами статического анализа), потому как ошибка, дожившая до времени выполнения, может до времени и не проявляться. Поэтому, собственно, современные языки так сложны --- они намеренно ограничивают возможности программиста, чтобы не дать тому допускать ошибки, которых можно было бы избежать.

Следующий этап жизненного цикла программы после разработки --- тестирование. Тестирование, и это важно, не может доказать отсутствие ошибок в программе, оно может лишь помочь обнаружить ошибки, которые в программе присутствуют. Где-то в 70-е годы проводились исследования в области автоматического доказательства корректности программ, но оказалось, что выписывание предусловий и постусловий для сколько-нибудь сложной программы занимает больше времени, чем написание самой программы, к тому же в самих пред- и постусловиях могут быть ошибки. Да и автоматически доказательство строится не быстро, так что сейчас такие вещи особо не используются. Есть, правда, программирование по контракту, в основном вокруг которого строится, например, язык Eiffel, там предусловия и постусловия выписываются явно, но проверяются во время выполнения (так что это не то). Контракты в том или ином виде есть много где, в том числе в Java, и мы про них поговорим на одной из следующих пар.

Теперь, собственно, тестирование. Тестирование бывает модульным --- когда тестируются отдельные модули (функции, методы, классы, и т.д.), интеграционное (когда тестируется взаимодействие набора модулей системы), и системное (когда тестируется вся система целиком, в рабочих условиях). Интеграционное тестирование и системное тестирование обычно выполняются специально обученными людьми, а вот модульное тестирование --- самими программистами. Модульное тестирование заключается в том, что для каждой нетривиальной функции или метода пишутся свои тесты, которые проверяют, что метод работает как надо. Предполагается, что модульные тесты будут запускаться после каждой сборки программы, поэтому они должны работать по возможности быстро. Принято не продолжать разработку, если есть хотя бы один не прошедший модульный тест.

\subsection{Почему модульные тесты полезны}

Они помогают найти кучу ошибок на ранних этапах. Если тесты запускаются достаточно часто, вы будете помнить, что вы такое поменяли, после чего тесты перестали проходить.
Тест --- это способ вызвать кусок функциональности, который вы разрабатываете, до того, как будет готово всё остальное.
Тесты облегчают изменение программы. Вы что-то поменяли, что не должно отразиться на наблюдаемом поведении вашего класса или метода, запускаете тесты и смотрите, что они действительно все прошли. Юнит-тесты очень полезны для рефакторинга, они дают некую уверенность, что всё хорошо.

Тесты можно рассматривать как документацию к коду --- любой, кто захочет воспользоваться вашим классом, может посмотреть в ваши юнит-тесты к этому классу и посмотреть, как его использовать.
Тесты помогают улучшить структуру программы --- дикую мешанину невозможно толком оттестировать, так что волей-неволей придётся задуматься об аккуратной архитектуре.

\subsection{Юнит-тесты на Java}

Модульное тестирование на Java осуществляется с помощью библиотеки jUnit, разработанной Эрихом Гамма и Кентом Беком (членами ``банды чётырёх'', они же писали книжку про паттерны и вообще активно пропагандировали ООП, Java, Agile и подобные вещи). Идея очень проста ---  каждому классу соответствует класс с таким же именем + Test на конце, который содержит тесты для всех методов класса. Есть программа, которая умеет последовательно запускать все тесты в тестовом классе и как-то обрабатывать результат. Сейчас такая штука обычно встроена в IDE, но принцип, как и в ранних версиях, такой --- если все тесты прошли, загорается зелёная полоска, если хоть один не прошёл --- красная, и пишется информация, какой тест не прошёл и почему. Сами тесты --- это просто методы тестового класса, помеченные специальной аннотацией @Test, имя их обычно совпадает с именем тестируемого метода, но начинается с test (есть и другие распространённые соглашения, см. \url{http://stackoverflow.com/questions/155436/unit-test-naming-best-practices}), а внутри что-то делается (готовятся данные), вызывается метод, который хотим протестировать, и смотрим на результат --- вызывая специальные методы типа assertEquals, fail и т.д. В общем, идея простая, но хорошая, поэтому jUnit была переписана на очень многих языках, в том числе для .NET --- там она называется NUnit, для С++ прямой порт не сделать, потому что там рефлексии нет, но аналогов полно --- Google Testing Framework, CppUnit, CxxTest и т.д. Несложная система модульного тестирования пишется за выходные, а особо сложных и не бывает.

\subsection{Демонстрация}

Сделаем небольшой проект и юнит-тесты для него (кстати, юнит-тесты обязательны для каждой задачи в домашке). Создаём новый проект в IDEA, пишем там что-нибудь, что можно тестировать (например, факториал):

\begin{minted}{java}
public class Main {
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;
        }

        return n * factorial(n - 1);
   }

   public static void main(String[] args) {
   }
}
\end{minted}

Дальше позволяем IDEA сделать всё за нас: ставим курсор на класс Main, жмём Alt-Enter, выбираем Create Test. Выбираем JUnit5,  выбираем методы, для которых надо сгенерить тесты, получаем что-то такое:

\begin{minted}{java}
package com.example;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class MainTest {

    @Test
    void factorial() {
    }
}
\end{minted}

Теперь можно писать, собственно, тесты, используя статические методы класса Assert, который мы для удобства статически прилинкуем:
\begin{minted}{java}
package com.example;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class MainTest {

    @Test
    void factorial() {
       assertEquals(120, Main.factorial(5));
    }
}
\end{minted}

Запускаем тест кнопкой рядом с тестом, убеждаемся, что он проходит. Портим факториал, убеждаемся, что тест не проходит больше. Обратите внимание на @Test --- это те самые атрибуты, про которые я рассказывал на прошлой паре, с их помощью раннер JUnit знает, какие методы надо запустить. Ещё обратите внимание, что теперь вообще не нужен метод main --- каждый тест может служить точкой входа (запускаемым методом). Ещё из интересных атрибутов бывают @BeforeEach, @AfterEach, @BeforeAll, @AfterAll, но в силу крайней ограниченности времени пары про них предлагается нагуглить самостоятельно.

Последнее, про что хочется упомянуть --- это best practices юнит-тестирования:
\begin{itemize}
	\item тесты должны быть независимыми, то есть в идеале одна поломка в коде должна ломать один тест;
	\item имеет смысл изолировать тестируемые объекты, для этого могут применяться mock-объекты (тоже полезно погуглить);
	\item тесты должны работать быстро;
	\item тесты должны проверять конкретный сценарий работы системы, никаких try-catch в коде теста быть не должно, используйте assertThrows;
	\item тестов должно быть много (погуглите про coverage);
	\item есть клёвая библиотека Apache Hamcrest, стоит глянуть.
\end{itemize}

\section{Системы сборки}

Следующее семейство технологий, которое используется во всех больших проектах --- это системы сборки. Они нужны для автоматизации билда приложения, который в больших проектах может быть чрезвычайно сложной процедурой, состоящей из нескольких фаз сборки исходников, сборки инсталляторов, сборки документации, деплоя (возможно, на удалённый сервер, а возможно, на целую инфраструктуру серверов), различных манипуляций с ресурсами, запуска юнит-тестов и т.д. Нередки проекты, в которых билд идёт несколько часов. Я работал в проекте, где билд требовал запуска трёх виртуалок, сборки отдельной части проекта кросскомпилятором и выкладывания её в гит, укачивания из гита её и ещё парочки заранее собранных компонентов, включения в инсталлятор вместе с только что собранными под конкретную ОС исходниками и заливки инсталлятора (инсталляторов под 4 поддерживаемые ОС, на самом деле) на сервер репозитория для рассылки автообновлений. Если делать это вручную, можно сойти с ума, к тому же, велика вероятность совершить ошибку и выложить в продакшн что-то не то.

Есть распространённое заблуждение, что среда разработки и так вам всё соберёт. Но если вы собираете проект только локально, может оказаться так, что только у вас этот проект и собирается. Чтобы этого избежать, придумали Continious Integration --- отдельный билд-сервер, подписанный на сообщения о коммитах и собирающий проект после каждого коммита автоматически (и запускающий юнит-тесты, кстати). Есть несколько таких бесплатных для опенсорс-проектов штук в облаке, например, Travis или AppVeyor. На билд-сервере никакой IDE нет, всё должно запускаться из командной строки.

Типичная система сборки (например, make) умеет выполнять некоторые действия для сборки проекта в правильном порядке, действия обычно называются задачами, а порядок определяется зависимостями между задачами (например, нет смысла запускать юнит-тесты, если проект ещё не собран). Система сборки строит граф задач и выполняет на нём топологическую сортировку, после чего начинает последовательно исполнять задачи, передавая, возможно, результаты одной как входные параметры другой. Всё это управляется конфигурационным файлом сборки, где задачи могут быть описаны явно (как это надо было делать в make) или декларативно (как в Maven). Задачи могут быть не только вызовами компилятора, с помощью систем сборки можно автоматизировать любой процесс, где есть входные данные, несколько разных программ или действий, которые надо на входных данных выполнить, получить выходные данные и, возможно, выполнить на них ещё что-то (например, конвертить картинки в папке или расставлять тэги mp3-файлам вполне можно и make-ом). Этим системы сборки похожи на скрипты (bash, cmd), но в скриптах практически всё надо писать руками и результат окажется непереносимым между платформами (да даже между разными командными интерпретаторами на одной платформе).

В мире Java весьма популярны системы сборки Ant (очень похожа на make, поэтому считается отжившей свой век и deprecated), Maven и Gradle. Расскажу подробнее про две последние.

\subsection{Apache Maven}

Maven --- это система сборки, которую написали, когда поняли, что на Ant надо писать кучу кода на XML, который ещё и тяжело переиспользуется между проектами (кстати, Ant появился в 2000 году, Maven --- в 2004, Gradle --- в 2008). Maven позволяет не писать действия при сборке, а позволяет описать конфигурацию сборки, остальное билд-система сделает сама (декларативный стиль описания сборки). При этом он использует подход ``Convention Over Configuration'', то есть ожидает от проекта следования некоторому набору правил и определяет ряд умолчаний, так, что если всё хорошо, то билд требует лишь минимальной конфигурации. Вот пример минимальной конфигурации, позволяющей собрать автоматически java-исходники и тесты, запустить тесты и собрать .jar-архив:

\begin{minted}{xml}
<project xmlns="http://maven.apache.org/POM/4.0.0" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">

    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>testApp</artifactId>
    <version>1.0</version>

    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
\end{minted}

Тут описывается лишь информация про проект в духе его названия и версии, описывается зависимость от библиотеки JUnit. Негативная сторона такого удобства в том, что если ваш проект не следует стандартным соглашениям, надо помучиться, чтобы Maven переубедить.

Сам Maven практически ничего делать не умеет, поэтому размер установщика --- всего полтора мегабайта (вообще, он есть в установке IDEA, поэтому отдельно ставить его не нужно). Всё делается плагинами, которые подкачиваются из репозитория по мере их первого использования. Плагины интегрируются в фазы жизненного цикла сборки, которые определены в самом Maven (там есть фазы типа валидации, компиляции, запуска юнит-тестов, деплоя и т.д.). 

Ключевой для Maven файл --- это pom.xml, Project Object Model, где хранится информация о проекте и его конфигурации, о том, как его собирать, от кого он зависит, и вообще, что с ним надо делать. Собственно, этого файла в корн проекта достаточно, чтобы Maven мог собирать проект. При этом в POM единственная обязательная штука --- это ``координаты'' проекта, которые позволяют его однозначно идентифицировать, в том числе и глобально, если проект будет выложен в общий репозиторий. Координаты состоят из groupId --- чего-то вроде имени пакета Java, как правило, доменного имени компании --- автора приложения, artifactId --- имени самого приложения, и версии, записанной по определённой (довольно классической) схеме (<major version>.<minor version>.<release>-<modifier>).

Координаты пакетов используются для того, чтобы Maven мог автоматически подкачивать зависимости из интернета (что выгодно отличает его от make и подобных вещей), можно просто задекларировать, что хочу JUnit такой-то версии, и при сборке Maven сам его найдёт (у себя в облачном репозитории) и скачает. Причём, скачает в локальный кеш (который лежит в ~/.m2, ~ --- это папка пользователя, которая под Windows что-то вроде  C:/Users/<пользователь>), и при последующих сборках будет использовать скачанные пакеты.

Вот стандартная структура папок Maven:

\begin{minted}{text}
pom.xml
src
    main
        java
        resources
    test
        java
        resources
target
\end{minted}

Папку target Maven создаст сам при сборке и положит туда результаты (файлы .class, .jar-архив), остальные папки надо (если надо) создать вручную. Идея, в общем-то, тут тоже в состоянии всё сделать за вас. Если вам не нравится идея класть исходники конкретно в папку src/main/java и вы хотите положить их в mysrc/awesomeApp/javarip, то, в общем-то, Maven не для вас (его можно переубедить, но это ``против шерсти'').

\subsubsection{Демонстрация}

Создаём в Идее новый проект, выбираем Maven, чтобы было как-то так:

Жмём next, указываем в следующем окошке координаты проекта, затем --- имя проекта и его положение на диске. Должен сгенериться тот самый минимальный POM, который я показывал (только пока без JUnit). Идём в src/main/java и создаём там какой-нить класс, создаём для него юнит-тест, как было чуть выше, обращаем внимание на незаметную кнопку Maven Projects справа. Это, собственно, фазы жизненного цикла Maven, выбираем Lifecycle/test, жмём run maven build, наслаждаемся первым успешным билдом в Maven. Впрочем, билд может быть и неуспешным, потому что Maven хочет иметь в окружении переменную JAVA\_HOME или ещё на что-нибудь ругаться, при этом IDEA не очень информативно выдаёт сообщения об ошибке. Тогда надо запустить билд из консоли. Maven из поставки Идеи у меня лежит в папке C:\\Program Files (x86)\\JetBrains\\IntelliJ IDEA 2016.2.2\\plugins\\maven\\lib\\maven3\\bin, его можно добавить в переменную окружения PATH, потом в папке проекта (там, где лежит pom.xml) выполнить команду mvn install и посмотреть, что ему не понравится.

\subsection{Gradle}

Gradle --- это более свежая альтернатива Maven, которая появилась из-за того, что Maven слишком навязывает проектам своё видение процесса сборки и не все большие проекты могут этому видению следовать. Кроме того, xml-конфигурация Maven слишком многословна (в силу особенностей синтаксиса XML), поэтому решили использовать для написания конфигурации сборки язык программирования высокого уровня, более конкретно, Groovy. Поскольку Gradle появился на основе опыта Maven, он использует, в общем-то, тот же подход --- Convention Over Configuration, стандартную структуру папок. Но, в отличие от Maven, он позволяет писать конфиг билда и в императивном стиле, работая напрямую с задачами, и переопределять всё, что можно, без особой головной боли. Кроме того, Gradle позволяет пользоваться мавеновскими репозиториями и качать пакеты из них.

Собственно, конфиг сборки в Gradle описывается в файле build.gradle. Если создать новый проект, выглядит он примерно вот так:
\begin{minted}{groovy}
group 'com.example'
version '1.0-SNAPSHOT'

apply plugin: 'java'

sourceCompatibility = 1.8

repositories {
   mavenCentral()
}

dependencies {
   testCompile group: 'junit', name: 'junit', version: '4.11'
}
\end{minted}

Генерится ещё файл settings.gradle, который нужен для многопроектных сборок, в нём определяется структура дерева проектов. Для сборки из одного проекта он опционален.

Вот так можно переопределить дефолтные настройки:

\begin{minted}{groovy}
sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
    }
    test {
        java {
            srcDirs = ['test']
        }
    }
}
buildDir = 'out'
\end{minted}

--- папка с исходниками теперь будет <корень проекта>/src, папка с тестами --- <корень проекта>/test, а папка, куда кладутся собранные классы --- out.

\subsubsection{Демонстрация}

Как обычно, создаём в IDEA новый проект, но выбираем Gradle:

Дальше всё по аналогии с Maven-ом, в общем-то.

Тут я вынужден сделать отсылку к документации, в силу ограниченности времени пары. Благо документация на обе эти билд-системы хорошая и подробная, есть даже несколько разных книжек, которые легко нагуглить.

\end{document}

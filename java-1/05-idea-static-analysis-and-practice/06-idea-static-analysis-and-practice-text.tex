\documentclass[a5paper]{article}
\usepackage[a5paper, top=8mm, bottom=8mm, left=8mm, right=8mm]{geometry}

\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}

\usepackage{fontspec}
\setmainfont{FreeSerif}
\newfontfamily{\russianfonttt}[Scale=0.7]{DejaVuSansMono}

\usepackage[font=scriptsize]{caption}

\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{cite}

\usepackage[hang,multiple]{footmisc}
\renewcommand{\footnotelayout}{\raggedright}

\PassOptionsToPackage{hyphens}{url}\usepackage[xetex,linktocpage=true,plainpages=false,pdfpagelabels=false]{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}

\usepackage{tabu}

\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{footnote}
\usepackage{minted}

\sloppy
\pagestyle{plain}

\title{IDEA code inspections, практика}
\author{Юрий Литвинов\\\small{yurii.litvinov@gmail.com}}

\date{30.01.2019}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{IDEA code inspections}

По моему опыту, на продуктивность программиста в большей степени оказывает влияние не владение языком и не алгоритмическая подготовка, а скорее чисто технические навыки типа умения решат проблемы со сборкой и, главное, умение пользоваться инструментами, упрощающими разработку. Самый важный такой инструмент --- IDE. Фич у современных IDE и инструментов вокруг них много, сегодня рассмотрим статические анализаторы, или точнее --- IDEA code inspections.

Используется статический анализ для того, чтобы найти как можно больше багов ещё даже до запуска программы. Статические анализаторы --- это не альтернатива юнит-тестам, а скорее дополнение к функциональности поиска ошибок, встроенной в компилятор и сам язык программирования. Статический анализ тоже не может найти всех ошибок в программе и уж тем более доказать, что их нет (например, из-за проблемы останова машины Тьюринга: невозможно написать программу, которая для любой программы скажет, закончит она работать или нет). Тем не менее, статический анализ полезен, потому что иногда может поймать такие ошибки, которые юнит-тесты бы никогда не поймали. 

Настраивается встроенный в IDEA анализатор через меню Settings -> Editor -> Inspections, а запускается через меню Analyze -> Inspect Code... . Вы увидите, что встроенных анализаторов в IDEA очень много, причём они имеют разные параметры, позволяющие их настроить, и некоторые по умолчанию включены, некоторые нет. Имеет смысл почитать про эти анализаторы и включить как можно больше их. Почему не все --- некоторые анализаторы проверяют взаимоисключающие правила или противоречат стайлгайду, так что надо смотреть, чтобы не включить лишнего.

\section{Nullability Analysis}

Самый полезный, пожалуй, вид статического анализа из поддержанных IDEA --- это анализ на корректность использования null-ов, так называемый nullability-анализ. Работает он так: программист размечает свой код аннотациями \mintinline{java}|@NotNull| и \mintinline{java}|@Nullable| из пакета org.jetbrains.annotations, после чего анализато пытается доказать, что везде, где мы ожидаем NotNull, значение не может быть null-ом, и выдаёт предупреждение, если доказать не удалось. Аннотация \mintinline{java}|@Nullable| говорит, что значению разрешено быть null-ом, так что если мы пытаемся присвоить переменной, помеченной \mintinline{java}|@NotNull| значение переменной, помеченной \mintinline{java}|@Nullable|, это точно приведёт к сообщению об ошибке. Естественно, статический анализ можно обмануть, поэтому генерируются ещё проверки времени выполнения, которые заставляют программу упасть, если предположения программиста не были выполнены.

Аннотациями \mintinline{java}|@NotNull| и \mintinline{java}|@Nullable| можно помечать поля класса, параметры методов, возвращаемые значения методов, переменные. Проверки выполняются в основном ``на лету'', когда IDEA прямо в коде подсвечивает нарушения аннотаций. Ещё интересно, что она указвает на другие возможные ошибки, например, сравнение с null переменной, которая явно помечена как \mintinline{java}|@NotNull|.

Небольшой пример из документации:

\begin{minted}{java}
import org.jetbrains.annotations.NotNull;
import java.util.ArrayList;

public class TestNullable {
    public void foo(@NotBull Object param) {
        int i = param.hashCode();
    }

    public void callingNotNullMethod(ArrayList list) {
        if (list == null) {
            otherMethod(list);
        }

        foo(list);
    }
}
\end{minted}

Обратите внимание, что правильные аннотации находятся в пакете org.jetbrains.annotations, который IDEA умеет добавлять в проект сама. Но всё равно про него нужно помнить и не забывать включать в build.gradle, pom.xml и т.д. Такие же аннотации есть в некоторых других пакетах (например, были в com.sun.internal.что-то-там), с ними статический анализ работать, скорее всего, не будет.

По поводу рекоммендаций к использованию этих аннотаций всё просто --- чем больше, тем лучше. Локальные переменные с маленькой областью видимости помечать, наверное, не стоит, а вот поля и параметры методов (особенно public) бывает очень полезно (поэтому обязательно в домашке начиная с сегодняшнего дня). 

Кстати, в Java есть тип \mintinline{java}|Optional<T>|, представляющий наличие или отсутствие значения (как Maybe в некоторых функциональных языках), он в каком-то смысле альтернатива nullability-анализу. В каком: мы договариваемся вообще не использовать null никогда, если значения всё-таки может не быть, представлять его Optional и отсутствие значения представлять Optional.empty(). Но проблема в том, что Optional сам ссылочный тип, следовательно, может быть null, и компилятор без сторонней помощи проверить корректность программы никак не может. Так что nullability-анализ круче. У него есть один важный минус --- хорошо инструментально поддержан он только в некоторых средах разработки, конкретно то, про что тут рассказывается --- вообще только в IDEA. В консольной сборке всё тоже работает, но только во время выполнения, предупреждения при компиляции выдаваться не будут.

\section{Контракты}

На самом деле, nullability-анализ --- это частный случай более крутой функциональности, связанной с определением и проверкой \textit{контрактов}. В IDEA есть специальная аннотация \mintinline{java}|@Contract|, позволяющая задать ожидаемое поведение метода (в духе ``если выполнено такое-то предусловие, то должно быть выполнено такое-то постусловие''). Поведение проверяется как статически (ну, что возможно), так и генерацией проверок времени выполнения. Контракты описываются довольно хитро и вместе с тем довольно немногое можно описать. Вот некоторые примеры:

\begin{itemize}
	\item \mintinline{java}|@Contract("null -> null")| --- если методу передали в качестве параметра null, он должен вернуть null.
	\item \mintinline{java}|@Contract("_ -> this")| --- что бы ни передали методу, он должен вернуть указатель на текущий объект.
	\item \mintinline{java}|@Contract("!null, _ -> param1; null, !null -> param2; null, null -> fail")| --- метод возвращает первый из двух параметров, который не null (если первый параметр не null, возвращается он, если второй не null, а первый null, то возвращается второй, если оба null, бросается исключение).
\end{itemize}

Более подробно про это дело рекомендуется почитать в документации: \url{https://www.jetbrains.com/help/idea/contract-annotations.html}.

\section{Задача на практику}

Требуется реализовать generic-класс \mintinline{java}|Maybe<T>|, который очень похож по функциональности на \mintinline{java}|Optional<T>| из стандартной библиотеки. А именно, надо реализовать методы:

\begin{itemize}
	\item \mintinline{java}|public static <T> Maybe<T> just(T t)| --- создаёт новый объект типа \mintinline{java}|Maybe<T>|, хранящий в себе переданное значение.
	\item \mintinline{java}|public static <T> Maybe<T> nothing()| --- создаёт новый объект типа \mintinline{java}|Maybe<T>|, указывающий на отсутствие значения.
	\item \mintinline{java}|public T get()| --- возвращает значение, если оно есть, бросает исключение, если нету.
	\item \mintinline{java}|public boolean isPresent()| --- говорит, есть ли значение или нет.
	\item \mintinline{java}|public <U> Maybe<U> map(Function<?, ?> mapper)| --- возвращает новый объект типа \mintinline{java}|Maybe<U>|, полученный применением переданной функции из T в U к объекту \mintinline{java}|Maybe<T>|. Если было nothing(), должно и быть nothing(), если было значение, то применяется функция к значению и результат оборачивается в just(). Тут надо подумать, что написать вместо вопросиков, потому что просто \mintinline{java}|Function<T, U>| будет не очень.
\end{itemize}

Maybe должно быть можно создать только статическими методами just и nothing. Бонусное задание --- метод nothing() не должен создавать новые объекты каждый раз.

Дальше надо попользовать Maybe для преобразования чисел из файла.

\begin{itemize}
	\item Читаем файл построчно.
	\item Если в файле на строке было не число, должно создаться nothing().
	\item Если в файле было число, должно создаться Maybe с этим числом.
	\item Все прочитанные Maybe складываются в список.
	\item После того, как первый файл дочитан, создаётся второй файл и туда выводятся:
	\begin{itemize}
		\item ``nothing'', если в Maybe было не число;
		\item квадрат числа, если в Maybe было число.
	\end{itemize}
\end{itemize}


\end{document}

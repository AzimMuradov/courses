\documentclass[xetex,mathserif,serif]{beamer}
\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}
\usepackage{minted}
\usepackage{tabu}
\usepackage{forest}
\usepackage{moresize}
\usetikzlibrary{arrows}

\useoutertheme{infolines}

\usepackage{fontspec}
\setmainfont{FreeSans}
\newfontfamily{\russianfonttt}{FreeSans}

\definecolor{links}{HTML}{2A1B81}
\hypersetup{colorlinks,linkcolor=,urlcolor=links}

\setbeamertemplate{blocks}[rounded][shadow=false]

\setbeamercolor*{block title alerted}{fg=red!50!black,bg=red!20}
\setbeamercolor*{block body alerted}{fg=black,bg=red!10}

\tabulinesep=1.2mm

\title{Рефлексия}
\author[Юрий Литвинов]{Юрий Литвинов\\\small{\textcolor{gray}{yurii.litvinov@gmail.com}}}
\date{12.10.2018г}

\newcommand{\attribution}[1] {
\vspace{-5mm}\begin{flushright}\begin{scriptsize}\textcolor{gray}{\textcopyright\, #1}\end{scriptsize}\end{flushright}
}

\begin{document}

	\frame{\titlepage}

	\begin{frame}
		\frametitle{Рефлексия}
		\begin{itemize}
			\item Позволяет во время выполнения получать информацию о типах
			\begin{itemize}
				\item И главное, создавать объекты этих типов и вызывать их методы
			\end{itemize}
			\item Зачем:
			\begin{itemize}
				\item Плагины
				\item Анализаторы кода
				\item Тестовые системы
				\item ...
			\end{itemize}
			\item Проблемы:
			\begin{itemize}
				\item Медленно
				\item Нет помощи от системы типов
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Загрузка сборки}
		\begin{small}
			\begin{minted}{csharp}
public class Assembly {
    public static Assembly Load(AssemblyName assemblyRef);
    public static Assembly Load(String assemblyString);
    public static Assembly Load(byte[] rawAssembly)
    public static Assembly LoadFrom(String path);
    public static Assembly ReflectionOnlyLoad(String assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(String assemblyFile);
}
			\end{minted}
			например,
			\begin{minted}{csharp}
var a = Assembly.LoadFrom(@"http://example.com/ExampleAssembly.dll");
			\end{minted}
			Выгружать сборки нельзя
		\end{small}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример}
		\framesubtitle{Распечатать имена всех типов в сборке}
		\begin{footnotesize}
			\begin{minted}{csharp}
using System;
using System.Reflection;

public static class Program {
    public static void Main() {
        string dataAssembly = "System.Data, version=4.0.0.0, "
                + "culture=neutral, PublicKeyToken=b77a5c561934e089";
        LoadAssemblyAndShowPublicTypes(dataAssembly);
    }

    private static void LoadAssemblyAndShowPublicTypes(string assemblyId) {
        var a = Assembly.Load(assemblyId);
        foreach (Type t in a.ExportedTypes) {
            Console.WriteLine(t.FullName);
        }
    }
}
			\end{minted}
		\end{footnotesize}
	\end{frame}

	\begin{frame}
		\frametitle{Создание экземпляра объекта}
		\begin{itemize}
			\item System.Activator.CreateInstance --- можно передавать тип или строку с именем типа
			\begin{itemize}
				\item Версии со строкой возвращают System.Runtime.Remoting.ObjectHandle, надо вызвать Unwrap()
			\end{itemize}
			\item System.Activator.CreateInstanceFrom --- вызывает LoadFrom для сборки
			\item System.Reflection.ConstructorInfo.Invoke --- просто вызов конструктора (несколько дольше писать, чем предыдущие варианты)
			\item Рефлексия ничего не знает о синонимах
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Создание экземпляра типа-генерика}
		\begin{footnotesize}
			\begin{minted}{csharp}
using System;
using System.Reflection;

internal sealed class Dictionary<TKey, TValue> { }

public static class Program {
    public static void Main() {
        Type openType = typeof(Dictionary<,>);
        Type closedType = openType.MakeGenericType(
                typeof(String), typeof(Int32));
        Object o = Activator.CreateInstance(closedType);
        Console.WriteLine(o.GetType());
    }
}
			\end{minted}
		\end{footnotesize}
	\end{frame}

	\begin{frame}
		\frametitle{Пример: как сделать свою плагинную систему}
		\begin{itemize}
			\item Сделать отдельную сборку с описанием интерфейса плагина и типов данных, которые он использует
			\begin{itemize}
				\item Менять её будет очень проблематично
			\end{itemize}
			\item Сделать ``ядро системы'' --- отдельную сборку, ссылающуюся на сборку с интерфейсом плагина
			\item Делать набор плагинов, ссылающихся на сборку с интерфейсом плагина и реализующих его
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример: интерфейс плагина}
		\begin{minted}{csharp}
namespace MyCoolSystem.SDK {
    public interface IAddIn {
        string DoSomething(int x);
    }
}
		\end{minted}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример: плагины}
		\begin{minted}{csharp}
using MyCoolSystem.SDK;

public sealed class AddInA : IAddIn {
    public String DoSomething(int x) {
        return "AddInA: " + x.ToString();
    }
}

public sealed class AddInB : IAddIn {
    public String DoSomething(int x) {
        return "AddInB: " + (x * 2).ToString();
    }
}
		\end{minted}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример: ядро системы}
		\begin{scriptsize}
			\begin{minted}{csharp}
public static class Program
{
    public static void Main()
    {
        string addInDir = Path.GetDirectoryName(Assembly.GetEntryAssembly().Location);
        var addInAssemblies = Directory.EnumerateFiles(addInDir, "*.dll");
        var addInTypes =
            addInAssemblies.Select(Assembly.Load)
                .SelectMany(a => a.ExportedTypes)
                .Where(t => t.IsClass 
                        && typeof(IAddIn).GetTypeInfo().IsAssignableFrom(t.GetTypeInfo()));

        foreach (Type t in addInTypes)
        {
            var addIn = (IAddIn)Activator.CreateInstance(t);
            Console.WriteLine(addIn.DoSomething(5));
        }
    }
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

	\begin{frame}
		\frametitle{Информация о типах}
		\begin{center}
			\begin{tiny}
				\begin{forest}
					for tree={rectangle,draw,l sep=1cm,s sep=3mm,edge=open triangle 60-}
					[Object
						[Reflection.MemberInfo
							[TypeInfo]
							[Reflection.FieldInfo]
							[Reflection.MethodBase
								[Reflection.ConstructorInfo]
								[Reflection.MethodInfo]
							]
							[Reflection.PropertyInfo]
							[Reflection.EventInfo]
						]
					]
				\end{forest}
			\end{tiny}
		\end{center}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример: распечатать информацию о полях и методах}
		\begin{scriptsize}
			\begin{minted}{csharp}
using System;
using System.Reflection;

public static class Program {
    public static void Main() {
        Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
        foreach (Assembly a in assemblies) {
            Console.WriteLine($"Assembly: {a}");
            foreach (Type t in a.ExportedTypes) {
                Console.WriteLine($"  Type: {t}");
                foreach (MemberInfo mi in t.GetTypeInfo().DeclaredMembers) {
                    var typeName = string.Empty;
                    if (mi is FieldInfo) typeName = "FieldInfo";
                    if (mi is MethodInfo) typeName = "MethodInfo";
                    if (mi is ConstructorInfo) typeName = "ConstructoInfo";
                    Console.WriteLine($"    {typeName}: {mi}");
                }
            }
        }
    }
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

	\begin{frame}
		\frametitle{Полезные свойства MemberInfo}
		\begin{itemize}
			\item Name (string) --- имя члена класса
			\item DeclaringType (Type) --- тип
			\item Module (Module) --- модуль, в котором он объявлен
			\item CustomAttributes (IEnumerable<CustomAttributeData>) --- коллекция атрибутов, соответствующих этому члену класса
			\begin{itemize}
				\item Пример --- модульные тесты
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Как что-нибудь сделать с MemberInfo}
		\begin{itemize}
			\item GetValue и SetValue для FieldInfo и PropertyInfo
			\item Invoke для ConstructorInfo и MethodInfo
			\item AddEventHandler и RemoveEventHandler для EventInfo
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Пример: создать объект и вызвать его метод}
		\begin{scriptsize}
			\begin{minted}{csharp}
using System;
using System.Reflection;
using System.Linq;

internal sealed class SomeType {
    public SomeType(int test) { }
    private int DoSomething(int x) => x * 2;
}

public static class Program {
    public static void Main() {
        Type t = typeof(SomeType);
        Type ctorArgument = Type.GetType("System.Int32");
        ConstructorInfo ctor = t.GetTypeInfo().DeclaredConstructors.First(
                c => c.GetParameters()[0].ParameterType == ctorArgument);
        Object[] args = { 12 };
        Object obj = ctor.Invoke(args);
        MethodInfo mi = obj.GetType().GetTypeInfo().GetDeclaredMethod("DoSomething");
        int result = (int)mi.Invoke(obj, new object[]{3});
        Console.WriteLine($"result = {result}");
    }
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Ключевое слово dynamic}
		\begin{scriptsize}
			\begin{minted}{csharp}
using System;

internal static class DynamicDemo
{
    public static void Main()
    {
        dynamic value;
        for (int demo = 0; demo < 2; demo++)
        {
            value = (demo == 0) ? (dynamic)5 : (dynamic)"A";
            value = value + value;
            M(value);
        }
    }

    private static void M(int n) { Console.WriteLine("M(int): " + n); }
    private static void M(string s) { Console.WriteLine("M(string): " + s); }
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Генерация кода ``на лету''}
		\begin{scriptsize}
			\begin{minted}{csharp}
public static void Main() {
    AssemblyName assemblyName = new AssemblyName {Name = "HelloEmit"};
    AppDomain appDomain = AppDomain.CurrentDomain;
    AssemblyBuilder assemblyBuilder = appDomain.DefineDynamicAssembly(
        assemblyName, AssemblyBuilderAccess.Save);
    ModuleBuilder moduleBuilder = 
        assemblyBuilder.DefineDynamicModule(assemblyName.Name, "Hello.exe");
    TypeBuilder typeBuilder = moduleBuilder.DefineType("Test.MainClass",
        TypeAttributes.Public | TypeAttributes.Class);
    MethodBuilder methodBuilder = typeBuilder.DefineMethod("Main",
        MethodAttributes.Public | MethodAttributes.Static,
        typeof(int), new[] { typeof(string[]) });

    ILGenerator ilGenerator = methodBuilder.GetILGenerator();
    ilGenerator.Emit(OpCodes.Ldstr, "Hello, World!");
    ilGenerator.Emit(OpCodes.Call,
        typeof(Console).GetMethod("WriteLine", new[] { typeof(string) }));
    ilGenerator.Emit(OpCodes.Ldc_I4_0);
    ilGenerator.Emit(OpCodes.Ret);

    typeBuilder.CreateType();
    assemblyBuilder.SetEntryPoint(methodBuilder, PEFileKinds.ConsoleApplication);
    assemblyBuilder.Save("Hello.exe");
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

\end{document}

## Домашняя работа 1: Параллельное умножение матриц

**Дедлайн: 2 недели**

**Баллов: 4**

Одна из самых полезных и вместе с тем хорошо параллелящихся задач — умножение матриц. Это часто используется не только в научных расчётах, но и при практически любой работе с графикой, особенно трёхмерной. Фактически, современные видеокарты — это специализированные вычислители, умеющие умножать матрицы (в частности, вектора на матрицы) очень эффективно за счёт большого количества вычислительных узлов (до сотен в современных выделенных видеокартах). Естественно, параллельно. Вам надо попробовать поумножать матрицы с помощью обычного многоядерного процессора.

Требуется реализовать параллельное умножение для плотных целочисленных матриц. На входе программа получает два файла с матрицами (не обязательно квадратными), на выходе должен получиться файл, содержащий матрицу — их произведение. Сравнить скорость работы с последовательным вариантом в зависимости от размеров матриц, причём сделать это по возможности грамотно:

- Для каждого тестового случая выполнить N запусков, посчитать матожидание и среднеквадратичное отклонение
- Сделать это для нескольких разных и достаточно больших размеров матриц
- Свести результаты в таблицу, может даже построить график

Попробовать получить возможно большее ускорение.

Можно использовать только класс Thread для организации параллельной работы.

Обратите внимание, что распараллеливание имеет смысл только на достаточно больших данных, так что требуется также уметь генерировать большие тестовые данные и найти такие размеры данных, при которых различия в скорости работы будут заметны и значительны.

В качестве решения приложите пуллреквест в собственный репозиторий на GitHub. Как обычно, ожидаются комментарии, юнит-тесты, CI, следование правилам стайлгайда и здравого смысла.

## Домашняя работа 2: Lazy

**Дедлайн: 2 недели**

**Баллов: 5**

Реализовать следующий интерфейс, представляющий ленивое вычисление:

```
public interface ILazy<T> { T Get(); }
```

Объект Lazy создаётся на основе вычисления (представляемого объектом `Func<T>`, который передаётся в конструктор, далее supplier)

- Первый вызов Get() вызывает supplier и возвращает результат
- Повторные вызовы Get() возвращают тот же объект, что и первый вызов
- Вычисление должно запускаться не более одного раза (то есть supplier после первого вызова не нужен и может быть удалён сборщиком мусора)

Интерфейс должен быть реализован двум способами: 

- Простая версия с гарантией корректной работы в однопоточном режиме (без синхронизации)
- Гарантия корректной работы в многопоточном режиме
  - При этом она должна по возможности минимизировать число необходимых синхронизаций (если значение уже вычислено, не должно быть блокировок)
- supplier вправе вернуть null
- Библиотечным Lazy пользоваться, естественно, нельзя

Нужно:

- CI, на котором проходят ваши тесты
- Тесты
  - Однопоточные, на разные хорошие и плохие случаи
  - Многопоточные, на наличие гонок
  - Тесты на общее для двух реализация поведение не должны дублироваться

## Домашняя работа 3: MyThreadPool

**Дедлайн: 3 недели**

**Баллов: 15**

Реализовать простой пул задач (наподобие https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool?view=net-8.0 + https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory?view=net-8.0) с фиксированным числом потоков (число задается в конструкторе)

- При создании объекта `MyThreadPool` в нем должно начать работу n потоков
- У каждого потока есть два состояния: ожидание задачи / выполнение задачи
- Задача — вычисление некоторого значения, описывается в виде `Func<TResult>`
- При добавлении задачи, если в пуле есть ожидающий поток, то он должен приступить к ее исполнению. Иначе задача будет ожидать исполнения, пока не освободится какой-нибудь поток
- Задачи, принятые к исполнению, представлены в виде объектов интерфейса `IMyTask<TResult>`
- Метод `Shutdown` должен завершить работу потоков. Завершение работы коллаборативное, с использованием `CancellationToken` — уже запущенные задачи не прерываются, но новые задачи не принимаются на исполнение потоками из пула. 
  - Возможны два варианта решения — дать всем задачам, которые уже попали в очередь, досчитаться, либо выбросить исключение во все ожидающие завершения задачи потоки
  - `Shutdown` не должен возвращать управление, пока все потоки не остановились
- `IMyTask`
  - Свойство `IsCompleted` возвращает `true`, если задача выполнена 
  - Свойство `Result` возвращает результат выполнения задачи   
    - В случае, если соответствующая задаче функция завершилась с исключением, этот метод должен завершиться с исключением `AggregateException`, содержащим внутри себя исключение, вызвавшее проблему
    - Если результат еще не вычислен, метод ожидает его и возвращает полученное значение, блокируя вызвавший его поток
  - Метод `ContinueWith` — принимает объект типа `Func<TResult, TNewResult>`, который может быть применен к результату данной задачи X и возвращает новую задачу Y, принятую к исполнению
    - Новая задача будет исполнена не ранее, чем завершится исходная
    - В качестве аргумента объекту `Func` будет передан результат исходной задачи, и все Y должны исполняться на общих основаниях (т.е. должны разделяться между потоками пула)
    - Метод `ContinueWith` может быть вызван несколько раз
    - Метод `ContinueWith` не должен блокировать работу потока, если результат задачи X ещё не вычислен
    - `ContinueWith` должен быть согласован с `Shutdown` — принятая как `ContinueWith` задача должна либо досчитаться, либо бросить исключение ожидающему её потоку.

При этом:

- В данной работе запрещено использование TPL, PLINQ и библиотечных классов Task и ThreadPool.
- Все интерфейсные методы должны быть потокобезопасны
- Для каждого базового сценария использования должен быть написан несложный тест
- Также должен быть написан тест, проверяющий, что в пуле действительно не менее n потоков

Подсказка: задачи могут быть разных типов (например, можно `var myTask = myThreadPool.Submit(() => 2 * 2).ContinueWith(x => x.ToString());`). Хранить такие задачи в очереди можно, обернув их в `Action`.

## Домашняя работа 4: SimpleFTP

**Дедлайн: 3 недели**

**Баллов: 10**

Требуется реализовать сервер, обрабатывающий два запроса.

- List — листинг файлов в директории на сервере
- Get — скачивание файла с сервера

И клиент, позволяющий исполнять указанные запросы.

List, формат запроса:

```
1 <path: String>\n
```

- path — путь к директории относительно того места, где запущен сервер

Например, "1 ./Test/Files\n"

Формат ответа:

```
size (<name: String> <isDir: Boolean>)*\n
```

- size — количество файлов и папок в директории.
- name — название файла или папки. В кавычках, если с пробелами.
- isDir — флаг, принимающий значение "true" для директорий и "false" для файлов.

Например, "2 ./Test/files/file1.txt false ./Test/files/directory true\n"

Если директории не существует, сервер посылает ответ с size = -1

Get, формат запроса:

```
2 <path: String>\n
```

- path — путь к файлу относительно того места, где запущен сервер

Формат ответа:  

```
<size: Long> <content: Bytes>
```

- size — размер файла
- content — его содержимое

Если файла не существует, сервер посылает ответ с size = -1

В качестве разделителей между командами используются переводы строк, между частями команды — пробелы. Обратите внимание, что content — произвольный байтовый массив, в нём все эти символы могут встречаться, поэтому сначала передаётся size.

Сервер должен иметь возможность обслуживать несколько клиентов одновременно (например, в ситуации, когда три клиента одновременно скачивают большой файл).

Обратите внимание на строгое следование протоколу. Сервер любого правильного решения должен уметь взаимодействовать с клиентом любого другого правильного решения.

## Домашняя работа 5: MyNUnit

**Дедлайн: 3 недели**

**Баллов: 10**

Реализовать command-line приложение, принимающее на вход путь и выполняющее запуск тестов, находящихся во всех сборках, расположенных по этому пути:
- тестом считается метод, помеченный атрибутом Test;
- у атрибута может быть два аргумента — Expected для исключения, Ignore (со строковым параметром) — для отмены запуска и указания причины;
- перед и после запуска каждого теста в классе должны запускаться методы, помеченные атрибутами Before и After;
- перед и после запуска тестов в классе должны запускаться методы, помеченные атрибутами BeforeClass и AfterClass;
- BeforeClass и AfterClass должны быть статическими методами, при их запуске объект создаваться не должен.

Тесты должны запускаться возможно более параллельно. Помните, что пользователь вашей библиотеки не хочет сильно страдать из-за гонок в тестах (некоторый уровень страданий всё-таки допустим). И вообще, подумайте об удобстве пользователя (немаловажным фактором которого является, например, адекватная диагностика ошибок в тестах).

Приложение должно выводить в стандартный поток вывода отчет:
- о результате и времени выполнения прошедших и упавших тестов;
- о причине отключенных тестов.

Юнит-тесты на систему тестирования обязательны (при этом они должны быть написаны не на ней самой, а на чём-то более отлаженном, типа NUnit).

## Домашняя работа 6: MyNUnitWeb

**Дедлайн: 3 недели**

**Баллов: 10**

Реализовать веб-интерфейс для системы юнит-тестирования MyNUnit из предыдущей домашней работы. Требуется:

- Форма для загрузки на сервер сборок, которые надо тестировать;
  - Это может быть несколько файлов, например, .dll-ка с тестируемыми классами и .dll-ка с юнит-тестами к ним, их можно загружать по одному;
- Кнопка «Начать тестирование», запускающая юнит-тесты, по завершении которых должен отобразиться результат тестового прогона;
- Форма истории запусков, где можно просмотреть результаты всех тестовых прогонов, когда-либо запускавшихся на сервере:
  - Список всех сборок с тестами, общее количество успешных, проваленных и проигнорированных тестов по каждой сборке;
  - Список всех тестов в сборке (возможно, появляющийся при выборе сборки из первого списка), со статусом теста и временем его выполнения;
  - Если тест проигнорирован, с сообщением о причине.

+2 дополнительных балла за отображение результатов без перезагрузки страницы, +1 дополнительный балл за React + MaterialUI, +2 за деплой в Docker на Yandex.Cloud

Задание имеет дедлайн "до зачёта", поэтому можно начать, и подождать следующей пары, где мы подробнее разберём нужные вещи (например, использование EF Core).
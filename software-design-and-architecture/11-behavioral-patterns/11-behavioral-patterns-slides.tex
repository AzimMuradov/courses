\documentclass[xetex,mathserif,serif]{beamer}
\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}
\usepackage{minted}
\usepackage{tabu}

\useoutertheme{infolines}

\usepackage{fontspec}
\setmainfont{FreeSans}
\newfontfamily{\russianfonttt}{FreeSans}

\usepackage{textpos}
\setlength{\TPHorizModule}{1cm}
\setlength{\TPVertModule}{1cm}

\tabulinesep=1.2mm

\title[Шаблоны]{Лекция 8: Поведенческие шаблоны}
\author[Юрий Литвинов]{Юрий Литвинов\\\small{\textcolor{gray}{yurii.litvinov@gmail.com}}}
\date{21.04.2020г}

\newcommand{\DownArrow} {
	\hspace{2cm}\begin{LARGE}$\downarrow$\end{LARGE}
}

\newcommand{\attribution}[1] {
	\vspace{-5mm}\begin{flushright}\begin{scriptsize}\textcolor{gray}{\textcopyright\, #1}\end{scriptsize}\end{flushright}
}

\begin{document}

	\frame{\titlepage}

	\section{Паттерн ``Команда''}

	\begin{frame}
		\frametitle{Паттерн ``Команда'', мотивация}
		\begin{itemize}
			\item Хотим отделить инициацию запроса от его исполнения
			\item Хотим, чтобы тот, кто ``активирует'' запрос, не знал, как он исполняется
			\item При этом хотим, чтобы тот, кто знает, когда исполнится запрос, не знал, когда он будет активирован
			\item Но зачем?
			\begin{itemize}
				\item Команды меню приложения
				\item Палитры инструментов
				\item ...
			\end{itemize}
			\item ``Просто вызвать действие'' не получится, вызов функции жёстко свяжет инициатора и исполнителя
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Решение: обернём действие в объект}
		\begin{center}
			\includegraphics[width=0.9\textwidth]{commandExample.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Команда вставки}
		\begin{center}
			\includegraphics[width=0.75\textwidth]{pasteCommand.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Команда открытия документа}
		\begin{center}
			\includegraphics[width=0.75\textwidth]{openDocumentCommand.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Составная команда}
		\begin{center}
			\includegraphics[width=0.75\textwidth]{compositeCommand.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Паттерн ``Команда''}
		\begin{center}
			\includegraphics[width=0.9\textwidth]{command.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Взаимодействие объектов}
		\begin{center}
			\includegraphics[width=0.9\textwidth]{commandSequence.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Команда, применимость}
		\begin{itemize}
			\item Параметризовать объекты выполняемым действием
			\item Определять, ставить в очередь и выполнять запросы в разное время
			\item Поддержать отмену операций
			\item Структурировать систему на основе высокоуровневых операций, построенных из примитивных
			\item Поддержать протоколирование изменений
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{``Команда'' (Command), детали реализации}
		\begin{itemize}
			\item Насколько ``умной'' должна быть команда
			\item Отмена и повторение операций --- тоже от хранения всего состояния в команде до ``вычислимого'' отката
			\begin{itemize}
				\item Undo-стек и Redo-стек
				\item Может потребоваться копировать команды
				\item ``Искусственные'' команды
				\item Композитные команды
			\end{itemize}
			\item Паттерн ``Хранитель'' для избежания ошибок восстановления
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{``Команда'', пример}
		\begin{itemize}
			\item Qt, класс QAction:
			\begin{minted}{c++}
const QIcon openIcon = QIcon(":/images/open.png");
QAction *openAct = new QAction(openIcon, tr("&Open..."), this);

openAct->setShortcuts(QKeySequence::Open);
openAct->setStatusTip(tr("Open an existing file"));

connect(openAct, &QAction::triggered, this, &MainWindow::open);

fileMenu->addAction(openAct);
fileToolBar->addAction(openAct);
			\end{minted}
		\end{itemize}
\end{frame}

	\section{Паттерн ``Цепочка ответственности''}

	\begin{frame}
		\frametitle{Паттерн ``Цепочка ответственности'', мотивация}
		\begin{center}
			\includegraphics[width=0.7\textwidth]{chainOfResponsibilityExample.png}
		\end{center}
		\begin{itemize}
			\item Организация контекстной справки
			\item Если у элемента справки нет, запрос передаётся контейнеру
			\item Заранее неизвестно, кто в итоге обработает запрос
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Как это выглядит на диаграмме классов}
		\begin{center}
			\includegraphics[width=0.8\textwidth]{chainOfResponsibilityExampleClasses.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{``Цепочка ответственности'' (Chain of Responsibility), детали реализации}
		\begin{columns}
			\begin{column}{0.5\textwidth}
				\begin{itemize}
					\item Необязательно реализовывать связи в цепочке специально
					\begin{itemize}
						\item На самом деле, чаще используются существующие связи
					\end{itemize}
				\end{itemize}
			\end{column}
			\begin{column}{0.5\textwidth}
				\begin{center}
					\includegraphics[width=\textwidth]{chainOfResponsibility.png}
				\end{center}
			\end{column}
		\end{columns}
		\begin{itemize}
			\item По умолчанию в Handler передавать запрос дальше (если ссылки на преемника всё-таки есть)
			\item Если возможных запросов несколько, их надо как-то различать
			\begin{itemize}
				\item Явно вызывать методы --- нерасширяемо
				\item Использовать объекты-запросы
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{``Цепочка ответственности'', плюсы и минусы}
		\begin{itemize}
			\item Ослабление связанности
			\item Дополнительная гибкость при распределении обязанностей
			\item Получение не гарантировано
		\end{itemize}
		Когда использовать:
		\begin{itemize}
			\item Есть более одного объекта-обработчика запросов
			\item Конечный обработчик неизвестен и должен быть найден автоматически
			\item Хотим отправить запрос нескольким объектам
			\item Обработчики могут задаваться динамически
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{``Цепочка ответственности'', примеры}
		\begin{itemize}
			\item Распространение исключений
			\item Распространение событий в оконных библиотеках:
			\begin{minted}{c++}
void MyCheckBox::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        // handle left mouse button here
    } else {
        // pass on other buttons to base class
        QCheckBox::mousePressEvent(event);
    }
}
			\end{minted}
		\end{itemize}
	\end{frame}

	\section{Паттерн ``Состояние''}

	\begin{frame}
		\frametitle{Паттерн ``Состояние'', мотивация}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{stateExample.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{Паттерн ``Состояние''}
		\begin{center}
			\includegraphics[width=0.75\textwidth]{state.png}
		\end{center}
	\end{frame}

	\begin{frame}
		\frametitle{``Состояние'' (State), детали реализации}
		\begin{itemize}
			\item Переходы между состояниями --- в Context или в State?
			\item Таблица переходов
			\begin{itemize}
				\item Трудно добавить действия по переходу
			\end{itemize}
			\item Создание и уничтожение состояний
			\begin{itemize}
				\item Создать раз и навсегда
				\item Создавать и удалять при переходах
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{``Состояние'' результаты}
		\begin{itemize}
			\item Локализует зависящее от состояния поведение
			\item Делает явными переходы между состояниями
			\item Объекты состояния можно разделять
		\end{itemize}
		Когда применять:
		\begin{itemize}
			\item Поведение объекта зависит от его состояния и должно изменяться во время выполнения
			\item Обилие условных операторов, в которых выбор ветви зависит от состояния
		\end{itemize}
	\end{frame}

\end{document}

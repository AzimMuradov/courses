# Домашние работы по кусу "Проектирование программного обеспечения" (CSC)

## Домашняя работа 1. Архитектура CLI

**Дедлайн** — одна неделя  
**Баллов** — 10

В командах по два-три человека спроектировать простой интерпретатор командной строки, поддерживающий команды:

- cat [FILE] — вывести на экран содержимое файла;
- echo — вывести на экран свой аргумент (или аргументы);
- wc [FILE] — вывести количество строк, слов и байт в файле;
- pwd — распечатать текущую директорию;
- exit — выйти из интерпретатора.

При этом должны поддерживаться (и, соответственно, явно отражены в архитектуре):

- одинарные и двойные кавычки (full and weak quoting);
- окружение (команды вида "имя=значение"), оператор \$;
- вызов внешней программы, если введено что-то, чего интерпретатор не знает;
- пайплайны (оператор "|").

Примеры:

```
>echo "Hello, world!"
Hello, world!

> FILE=example.txt
> cat $FILE
Some example text

> cat example.txt | wc
1 3 18

> echo 123 | wc
1 1 3

> x=ex
> y=it
> $x$y
```

Решение должно удовлетворять следующим нефункциональным требованиям:

- легко добавлять новые команды;
- чёткое разграничение ответственности между элементами архитектуры;
  - это не должен быть просто клубок классов, требуется некая компонентная структура;
- наличие словесного архитектурного описания.

В следующих заданиях надо будет реализовать эту архитектуру, причём в два этапа — сначала без подстановок и пайпов, затем всё. Соответственно, решение должно отражать этапность разработки. Как — на ваше усмотрение (либо сделать две отдельные диаграммы и разбить текст на разделы "фаза 1" и "фаза 2", либо выделить на диаграмме цветом функциональность первого и второго этапа). Пока код писать не надо.

Результатом должна являться структурная диаграмма (например, диаграмма классов UML — пока как умеете), описывающая систему, и текстовое описание того, как спроектированное приложение должно работать. Решение сдаётся в виде .md или .pdf-файла в репозитории. При этом обязательно либо выложить исходник диаграммы, либо указать ссылку на исходник в каком-то из облачных сервисов.

В чём рисовать:

- https://www.diagrams.net/ — бесплатный и относительно неплохой веб-редактор диаграмм;
- https://www.genmymodel.com/ — тоже неплохой веб-редактор;
- https://www.visual-paradigm.com/download/community.jsp — десктопный бесплатный UML-редактор на Java.

Обязательно укажите, с кем вы в команде.

## Домашняя работа 2. Реализация CLI, часть 1
**Дедлайн** — две недели  
**Баллов** — 10

Реализовать в тех же командах, в которых делалась предыдущая домашняя работа, первую часть архитектуры Command-Line Interface из домашней работы 1, связанную с поддержкой Read-Execute-Print Loop и команд. Подстановки и пайпы пока не надо.

Должны поддерживаться:

- cat [FILE] — вывести на экран содержимое файла;
- echo — вывести на экран свой аргумент (или аргументы);
- wc [FILE] — вывести количество строк, слов и байт в файле;
- pwd — распечатать текущую директорию;
- exit — выйти из интерпретатора;
- если введено что-то, чего интерпретатор не знает — вызов внешней программы.

При этом:

- одинарные и двойные кавычки должны поддерживаться, хоть они ничем не отличаются без постановок: строка в кавычках — один аргумент;
- переменные окружения должны поддерживаться и передаваться внешнему процессу при запуске;
- для команд должны поддерживаться потоки вывода, ошибок и код возврата (для встроенных команд — на ваше усмотрение, для внешних процессов — что они вернут).

С технической точки зрения надо:

- чтобы оно собиралось и запускалось из консоли, а не только из вашей любимой IDE;
- очень желательно, чтобы оно работало и под Windows, и под Linux;
- процесс сборки и запуска должен описан в README.md;
- должны быть юнит-тесты;
- должен быть настроенный CI, где эти юнит-тесты бы запускались;
- должны быть комментарии к каждому типу и каждому public-методу;
- должен быть выложен в свой репозиторий проект системы из задания 1.

Сдавать в виде пуллреквеста в свой репозиторий. Ссылку на пуллреквест приложить в качестве решения.

## Домашняя работа 3. Реализация CLI, часть 2
**Дедлайн** — две недели  
**Баллов** — 10

Реализовать в командах по два человека вторую часть архитектуры Command-Line Interface из домашней работы 1: поддержку подстановок и пайпов.

- Делайте эту задачу в отдельной ветке на базе части первой CLI, сдавайте отдельным пуллреквестом.
- Если к первой части ещё не приступали, всё равно разделите на два пуллреквеста из двух отдельных веток.
- Обратите внимание на обработку ошибок — шелл никогда не должен падать из-за пользовательского ввода, по возможности адекватно выдавать диагностику.
- Не забудьте про юнит-тесты на новую функциональность.
- При реализации допустимо отклоняться от семантики bash и других популярных шеллов, особенно если это логично в вашей архитектуре. Например, подумайте про:
    - exit и его взаимодействие с пайпами;
    - ненулевой код возврата и его взаимодействие с пайпами;
    - что с пайпами и потоком ошибок.

## Домашняя работа 4. Grep
**Дедлайн** — две недели  
**Баллов** — 10

Реализовать в своём Command-Line Interface из предыдущих домашних заданий поддержку встроенной команды grep.

Требуется поддержка:

- регулярных выражений в запросе;
- ключа -w — поиск только слова целиком;
  - формально grep -w ищет подстроки, ограниченные "non-word constituent character", а именно не буквы, цифры или символ подчёркивания; однако что такое буквы — лучше спросить у вашей стандартной библиотеки, потому что бывает Unicode и его классы символов, ваша реализация может отличаться от настоящего поведения grep;
- ключа -i — регистронезависимый (case-insensitive) поиск;
- ключа -A — следующее за -A число говорит, сколько строк после совпадения надо распечатать, например, -A 0 печатает только строку, на которой найдено совпадение, а -A 10 — ещё и 10 строк ниже;
  - подумайте, что будет, если области печати пересекаются.

Поскольку для grep требуется нетривиальный разбор ключей, его необходимо реализовать с использованием одной из библиотек для разбора аргументов командной строки (например, Apache Commons CLI). Выбрать библиотеку необходимо самостоятельно, и, что самое главное, *описать в README.md, из чего выбирали и почему выбрали именно ту, что выбрали*.

Примеры:

```
> grep "Минимальный" README.md
Минимальный синтаксис grep

> grep "Минимальный$" README.md

> grep "^Минимальный" README.md
Минимальный синтаксис grep

> grep -i "минимальный" README.md
Минимальный синтаксис grep

> grep -w "Минимал" README.md

> grep -A 1 "II" README.md
```

Нужно также:

- обновить архитектурную документацию и заодно привести её к синтаксису UML, если она ему не соответствует;
- написать юнит-тесты на новую функциональность;
- написать комментарии.

Сдавать, как обычно, создав новую ветку для grep на базе предыдущей и сделав новый пуллреквест.

## Домашняя работа 5. Cd, ls
**Дедлайн** — две недели  
**Баллов** — 10

Реализовать в Command-Line Interface *одногруппников* встроенные команды cd и ls. При этом:

- обе команды могут принимать 0 или 1 аргумент, поведение их должно соответствовать поведению аналогичных команд традиционных шеллов (например, bash);
- может потребоваться изменение кода существующей реализации, поскольку cd меняет состояние шелла;
- текущая рабочая папка, которую меняет cd, должна меняться и для встроенных команд, и для внешних команд;
  - например, cd ../../.. и потом git status должно показывать статус репозитория тремя папками выше начальной папки;
- не забудьте про юнит-тесты.

Также надо написать краткое ревью на архитектуру и реализацию одногруппников, насколько просто было реализовать новые команды и добавить на них юнит-тесты. Опишите также (вежливо), что было удобным, что показалось неудобным, что и как можно было бы сделать лучше.

Сдавать работу надо, создав форк репозитория одногруппников и сделать пуллреквест в исходный репозиторий (если стесняетесь, допускается также пуллреквест в свой форк).

Кому в каком репозитории делать, определяется случайно преподавателем, ссылки на репозитории "жертв" будут разосланы каждому отдельно. Вполне может быть, что доставшаяся вам реализация на незнакомом вам языке программирования — цель этой задачи состоит ещё и в расширении кругозора.

## Домашняя работа 6. Архитектура Roguelike
**Дедлайн** — одна неделя  
**Баллов** — 10

Roguelike — это довольно популярный жанр компьютерных игр, назван в честь игры Rogue, 1980 года выхода. Характеризуется:

- простой тайловой или консольной графикой (современные игры roguelike-игры иногда имеют вид сбоку (Dead Cells, Noita) или даже 3D (Risk of Rain 2), но (псевдо-)консольных и тайловых тоже полно (Caves of Qud, Cogmind, например));
- активным использованием случайной генерации;
- перманентной смертью персонажа и невозможностью загрузить предыдущее сохранение (не чтобы позлить игрока, а чтобы дать ему возможность попробовать разных персонажей и разные пути развития);
- чрезвычайно развитым набором игровых правил (чем эти игры нам и интересны, модель их предметной области может быть как очень простой, так и невероятно сложной);
- высокой свободой действий персонажа (так называемые "игры-песочницы")

Классические примеры:

- https://en.wikipedia.org/wiki/NetHack
- https://en.wikipedia.org/wiki/Angband_(video_game)
- https://en.wikipedia.org/wiki/Ancient_Domains_of_Mystery

Вашей задачей будет в командах по два-три человека провести анализ и разработать архитектуру для такой компьютерной игры.

При этом должны быть выполнены следующие функциональные требования:

- персонаж игрока, способный перемещаться по карте, управляемый с клавиатуры;
  - карта обычно генерируется, но для некоторых уровней грузится из файла;
  - характеристики — здоровье, сила атаки и т.д.;
- у персонажа есть инвентарь, состоящий из вещей, которые он носит с собой;
  - вещи из инвентаря можно надеть и снять, надетые вещи влияют на характеристики персонажа;
  - вещи изначально находятся на карте, их можно поднять, чтобы добавить в инвентарь;
  - снятые вещи находятся в инвентаре, их можно надеть в дальнейшем;
- консольная графика, традиционная для этого жанра игр.

В данном задании требуется разделиться на команды по два-три человека и написать архитектурное описание Roguelike, как обычно пишутся design document-ы:

- общие сведения о системе;
- architectural drivers;
- роли и случаи использования;
  - описание типичного пользователя;
- композиция (диаграмма компонентов и её текстовое описание);
- логическая структура (диаграмма классов и её текстовое описание);
- взаимодействия и состояния (диаграммы последовательностей и конечных автоматов и их текстовое описание).

На что обратить внимание:

- на разделение системы на компоненты — решения вида "большой клубок классов" будут оценены очень низко;
- на прослеживаемость потока управления — должно быть понятно, с какого места запускается программа, кто кому передаёт управление;
- что все имеют необходимые для своей работы данные — например, пользовательский интерфейс знает про карту;
- на баланс детальности и читаемости диаграммы — она должна быть достаточно детальна, чтобы при реализации не требовалось принимать серьёзных архитектурных решений, но при этом обозрима. Например, старательно выписывать все методы классов и все поля не надо, но ключевые методы и поля всё-таки нужны;
- на следование синтаксису UML.

Эту архитектуру в следующих заданиях надо будет реализовать (в составе тех же команд, в которых она проектировалась). Далее каждую неделю будут появляться новые требования, поэтому проектируйте архитектуру расширяемой и по возможности гибкой.

## Домашняя работа 7. Roguelike, часть 1
**Дедлайн** — две недели  
**Баллов** — 10

В команде из двух-трёх человек реализовать архитектуру Roguelike из предыдущего задания. При этом:

- рекомендуется (хотя и не обязательно) использовать какую-либо готовую библиотеку для работы с консолью, но готовые фреймворки для разработки Roguelike-игр нельзя;
  - есть много туториалов по этому делу, смотреть в них можно, списывать нет;
  - постарайтесь не терять кроссплатформенности (у ncurses и даже python-библиотек на её основе могут быть проблемы под Windows, например);
  - как обычно, если что-то выбираете, обоснуйте выбор в архитектурной документации;
- нужны юнит-тесты, CI и комментарии ко всему, что public;
- надо обновить диздок, чтобы привести его в соответствие фактической реализации.

Напомним, что дальше будут появляться новые требования, которые надо будет реализовать в рамках этой кодовой базы.

## Домашняя работа 8. Roguelike, часть 2
**Дедлайн** — две недели  
**Баллов** — 10

В команде из двух-трёх человек продолжить работу над Roguelike. В этом задании требуется реализовать поддержку мобов по следующим требованиям:

- мобов должно быть несколько разных видов, различающихся характеристиками и поведением:
  - агрессивное поведение, атакуют игрока, как только его видят;
  - пассивное поведение, просто стоят на месте;
  - трусливое поведение, стараются держаться на расстоянии от игрока.
- нужна боевая система, в которой:
  - персонажи, пытающиеся занять одну клетку, наносят друг другу урон в соответствии с их параметрами (атаки и защиты, и, возможно, каких-либо ещё);
  - урон уменьшает количество хитпойнтов, и если их становится 0 или меньше, персонаж умирает;
- нужна система экспы и уровней:
  - при убийстве моба персонажу игрока начисляется некоторое количество очков опыта;
  - при наборе достаточного количества опыта персонаж получает следующий уровень, что приводит к росту его характеристик.

При этом надо использовать паттерны, обсуждавшиеся на теории:

- паттерн "Стратегия" для поддержки различных поведений мобов;
- используя паттерн "Декоратор", реализовать для игрока возможность конфузить мобов;
  - моб, находящийся под эффектом конфузии, перемещается, случайно выбирая соседнюю клетку;
  - эффект должен быть временным.

Эту задачу надо реализовывать, отведя новую ветку от предыдущей и, соответственно, открыв новый пуллреквест. 

Также надо обновить архитектурную документацию (как диаграмму, так и словесное описание), включив туда описание новой функциональности.

Не забудьте юнит-тесты и комментарии.

## Домашняя работа 9. Roguelike, часть 3
**Дедлайн** — две недели  
**Баллов** — 10

В команде из двух-трёх человек продолжить работу над Roguelike. В этом задании требуется улучшить генерацию карт и поддержку мобов. Разумеется, применяя паттерны с теории.

- Паттерн "Строитель" для параметризации генератора карт. Должно быть можно сообщить строителю, грузить карту из файла или сгенерировать, указать желаемые размеры карты, и вызвать метод build(), возвращающий сгенерированную карту.
- Паттерн "Абстрактная фабрика" для генерации разных стилей мобов — например, фэнтезийные мобы в духе "скелет", "дракон" и т.д., или научно-фантастические, в духе "киборг-бензопильщик" и т.п. Фабрикой должно быть можно параметризовать строитель из предыдущего пункта.
- Паттерн "Прототип" для мобов, реплицирующихся на поле боя — например, "ядовитая плесень", которая каждый ход с вероятностью p порождает свою копию в соседней свободной клетке. Можно игру "Жизнь" реализовать, если хочется :)

Как обычно, задача сдаётся отдельным пуллреквестом от ветки с предыдущей задачей. Стоит также время от времени подмерждивать в неё исправления к предыдущим задачам.

Также надо обновить архитектурную документацию (как диаграмму, так и словесное описание), включив туда описание новой функциональности.

Не забудьте юнит-тесты и комментарии.

## Домашняя работа 10. Roguelike, часть 4
**Дедлайн** — две недели  
**Баллов** — 10

Наконец, последняя домашняя работа про Roguelike. В этом задании надо применить поведенческие шаблоны для того, чтобы зарефакторить взаимодействие с пользователем и улучшить ИИ мобов:

- Паттерн "Команда" для реализации взаимодействия с пользователем — напрямую обращаться из UI к классам бизнес-логики теперь нельзя, все действия должны выполняться строго через команды. Использовать "умные" или "глупые" команды — на ваше усмотрение.
- Паттерн "Состояние" для придания "стратегичности" действиям моба. Напомним, что в одном из предыдущих заданий требовалось реализовать стратегии поведения. Сейчас поведение моба должно определяться его состоянием:
  - если здоровье моба ниже определённого уровня, он переходит в состояние "паника", в котором его текущая стратегия заменяется на трусливую (если изначально стратегия была трусливой, никаких изменений в поведении моба нет);
  - при восстановлении здоровья выше этого уровня моб переходит из состояния "паника" в состояние "всё ок", где переключается на исходную стратегию;
  - +3 бонусных балла за реализацию дополнительных стратегий и состояний (например, "патрулирую", "движусь в место последнего контакта с врагом", "выполняю поиск в районе последнего контакта", "атакую").

Как обычно, задача сдаётся отдельным пуллреквестом от ветки с предыдущей задачей.

Также, как обычно, надо обновить архитектурную документацию, включив туда описание новой функциональности.

## Домашняя работа 11. Магазин книг
**Дедлайн** — две недели  
**Баллов** — 10

Оформить в виде архитектурной документации (на сей раз не в команде) архитектуру сервиса "Магазин книг" по описанию из  https://goo.gl/94LyFc. Ожидается документ, состоящий из следующих разделов:

- общие сведения о системе;
- architectural drivers;
- роли и случаи использования;
- композиция (диаграмма компонентов и её текстовое описание);
- логическая структура (диаграмма классов и её текстовое описание).

В этом задании интересует прежде всего модель предметной области. Средства доставки (веб-приложение, веб-сервис) и инфраструктура (БД, сериализация в XML и т.п.) должны упоминаться, но не должны детализироваться.

Обратите внимание на соблюдение принципов предметно-ориентированного проектирования (желательно даже "чистой архитектуры"). Обозначьте классы, относящиеся, по вашему мнению, к смысловому ядру системы (например, выделив их на диаграмме цветом, либо вынеся в отдельный компонент).

## Домашняя работа 12. Сетевой чат
**Дедлайн** — две недели  
**Баллов** — 10

В командах по два человека доделать сетевой чат на gRPC с практики так, чтобы у него был графический пользовательский интерфейс. Требуется:
- отображение имени отправителя сообщения;
  - соответственно, и способ задать своё имя пользователя;
- отображение времени отправки сообщения;
  - обратите внимание, оно может не совпадать с временем получения;
- и конечно, отображение текста сообщения.

Приложение всё так же должно иметь возможность работать и как клиент, и как сервер, возможен одновременный чат только с одним пользователем (то есть контакт-листов, вкладок и т.п. делать не надо).

## Домашняя работа 13. Магазин книг-2
**Дедлайн** — две недели  
**Баллов** — 10

В командах по два человека доделать веб-сервис "Магазин книг" по заданию с практики и реализовать для него простой браузерный UI, использующий веб-сервис в качестве бэкенда. При этом:
- в качестве средства разработки UI можно использовать любой технологический стек, можно не тот, на котором писался сам веб-сервис;
- фронтенд и сервис должны быть двумя отдельными приложениями, фронтенд должен обращаться к сервису с помощью REST-запросов;
- вспомните хорошие практики проектирования распределённых приложений — в частности, отказоустойчивость: если сервис недоступен, фронтенд должен корректно сообщать об ошибке;
- не стоит увлекаться: это всё-таки игрушечный пример.
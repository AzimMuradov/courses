\documentclass{../../text-style}

\texttitle{Объектно-ориентированное программирование на C\#, введение}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Про что этот курс}

Этот семестр --- про объектно-ориентированное программирование и связанные вещи, а также технологические аспекты разработки ПО. То есть, в курсе не будет (или почти не будет) новых алгоритмов, зато будет много новых концепций и конкретных технологий, которые могут пригодиться на практике. Начнём мы с ликвидации безграмотности по языку C\#. Именно на примере этого языка будут объясняться основные концепции объектно-ориентированного программирования и вообще вещи, свойственные современным объектно-ориентированным языкам, но курс ни в коем случае не про C\#, знания могут быть легко распространены на C++, Java, Kotlin (который, кстати, похож на C\#). Дальше будет про ООП (основные понятия: объекты, классы, абстракция-инкапсуляция-наследование-полиморфизм и т.д.), про генерики, про события, лямбды, про реализацию пользовательских интерфейсов. Также будут затронуты и технологические аспекты: модульное тестирование, сборка и непрерывная интеграция, визуальное моделирование на языке UML, работа со сторонними библиотеками.

\section{Отчётность}

Домашек будет немного меньше, чем в первом семестре, но они будут объёмнее. Кроме того, домашек будет много в начале семестра (пока вас по другим предметам не задавило долгами), зато постепенно они сойдут на нет, а в мае домашек вообще не будет (отчасти потому, что накопятся доделки всякие, отчасти потому, что в мае всё внимание будет дипломникам и на учебные практики, так что на вас будет просто не хватать времени). При этом вам в каком-то смысле не повезло, потому что мы договорились с преподом по дискретке, что раз у них в этом семестре нет практики, домашки будут больше по дискретной математике. На самом деле, где-то к середине курса наши с дискреткой пути разойдутся, к сожалению --- там как раз будет много теории графов, которую нелишне попрактиковать, но к тому времени вас надо будет учить более важным штукам.

Пар будет только одна в неделю, так что особо углубляться в технические детали будет некогда, придётся больше гуглить и разбираться самостоятельно. В середине семестра будет контрольная, в конце семестра будет зачётная работа. Курс в этом семестре будет размещаться на экспериментальной системе поддержки обучения HwProj (разработанной как набор ученых практик студентами): \url{https://bit.ly/oop-2023}. Если там что-то не будет работать, это нормально, напишите об этом. Есть чат в Telegram (спросите у Знающих Людей, если не подписаны). Поскольку пара одна, предполагается более активное общение вне пары, пишите по любому вопросу. Снова будут дедлайны, в две недели, и пишите, если надо продление. Суммарно будет 10 домашек на примерно 60 баллов в сумме, но будут ещё дополнительные задачи и дополнительные условия к обязательным задачам на дополнительные баллы, так что при должном старании можно набрать почти в полтора раза больше баллов, чем надо на A. Также действует ограничение на попытки сдачи, три бесплатные, дальше -1 балл за каждую. Также -1 балл за каждую неделю просроченной сдачи (то есть до дедлайна --- полные баллы, за пять минут после дедлайна --- минус балл, за неделю и пять минут после дедлайна --- минус два). Кроме того, за невыполнение требований условия на момент сдачи также будут сниматься баллы, так что сдавать пустой проект в срок смысла нет. Зато не будет дедлайнов по исправлению (потому что без автоматизации за ними просто не уследить), но к концу мая должно быть сдано всё, включая исправления. В какой-то момент решения приниматься больше не будут. Кроме того, все штрафы вместе не могут быть больше половины стоимости задачи, так что первая задача (в один балл) вообще не будет штрафоваться, ей некуда. Домашки, как обычно, надо будет сдавать пуллреквестом в свой репозиторий на GitHub и ссылку выкладывать на Blackboard.

Ещё важно, что зачёт и контрольная учитываются отдельно. То есть, если все домашки сдали и написали контрольную, но слили зачёт --- то увы (это для поддержания интриги до конца семестра и мотивации писать контрольные хорошо).

Ориентировочно баллы надо будет набрать такие. Всего будет около 60 обязательных баллов за домашки (и сколько-то необязательных) и по 10 за контрольную и зачёт. Так что, чтобы получить такую-то оценку, надо набрать минимум:
\begin{itemize}
    \item A --- 58 баллов за домашки, 9 за контрольную и зачёт.
    \item B --- 56 баллов за домашки, 8 за контрольную и зачёт.
    \item C --- 53 баллов за домашки, 7 за контрольную и зачёт.
    \item D --- 51 баллов за домашки, 6 за контрольную и зачёт.
    \item E --- 48 баллов за домашки, 5 за контрольную и зачёт.
\end{itemize}

Баллы очень ориентировочные, потому что количество домашек и баллы за них будут корректироваться по ходу. В позапрошлом году задач было больше и народ жаловался, что сложно. В прошлом году задач было меньше и народ не жаловался --- значит, могут появиться новые задачи.

Как в прошлом семестре, будут доклады --- про разные технологии вокруг .NET. Успешный доклад даёт аж +6 баллов, что много (сравнимо со стоимостью одной домашки), и даёт шанс не вылететь (но доклады даются прежде всего тем, у кого мало баллов).

В принципе, в этом курсе всё будет рассказываться с нуля, но если то, что рассказывалось на лекциях, заинтересовало и хочется почитать поподробнее про то, как всё работает, рекомендую книгу Jeffrey Richter. CLR via C\#. Это фактически must read для любого профессионального .NET-программиста, хотя может быть сложновата на первом курсе и старовата (там про старый .NET Framework, так что детали могут быть просто неверны для современного .NET, но общие принципы такие). Может, к середине-концу семестра имеет смысл начать её читать. Есть ещё много разных книжек по C\#, так что если что-то на парах непонятно, можно посмотреть там, например, Джозеф Албахари, Бен Албахари <<C\# 9.0. Справочник. Полное описание языка>> или Джепикс Троелсен <<Язык программирования C\# 9 и платформа .NET 5>>. Ещё есть несколько годных блогов по .NET, но рекомендовать могу, пожалуй, только официальный блог Microsoft. А вот онлайн-курсы годные есть: \url{https://ulearn.me/} --- набор открытых онлайн-курсов от СКБ <<Контур>> и УрГУ, они неторопливо и с большим количеством примеров и подробностей покрывают почти всю нашу программу (и даже рассказывают немного сверх, типа паттернов). Очень рекомендую, если на парах будет сложновато (а скорее всего будет, у нас очень мало времени и очень много чему надо научиться до летних школ и летних стажировок).

\section{Язык C\#, введение}

Язык программирования С\# был разработан компанией Microsoft как основной язык программирования для платформы .NET, первая версия была представлена публике в 2002 году. Впоследствии он был стандартизован ECMA (ECMA-334) и ISO (ISO/IEC 23270:2006), то есть в данный момент является международным стандартом. Последняя на данный момент версия языка, C\# 11.0, опубликована 8 ноября 2022 года. Язык создавался как простой в использовании объектно-ориентированный язык общего назначения, с сильной типизацией. Используется в основном для написания прикладного ПО (включая настольные приложения, веб-приложения, он же используется для программирования под Windows Phone мобильных приложений). Всякие драйвера или системное ПО типа СУБД лучше писать на C++ (как правило, работать будет побыстрее, хотя это вопрос спорный в силу наличия в .NET развитых средств Just-in-time-компиляции). Программы, с которыми будут работать обычные пользователи --- типа банковских систем, программ складского учёта, информационных систем предприятия и т.д. вполне удобно писать на C\#, что очень многие и делают (язык занимает 5-е место в индексе TIOBE на февраль 2023, \url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html}). Ближайший конкурент C\# --- это, скорее, Java, языки довольно похожи (поначалу были очень похожи, но теперь их пути более-менее разошлись). Принципиальная разница в том, что Java ориентирована на кроссплатформенность, C\# создавался Microsoft для работы с их стеком технологий, однако же сейчас программы на C\# прекрасно работают практически на чём угодно, на не-Windows есть открытая реализация почти всего .NET (вот только без WPF и только с частичной поддержкой WCF). В общем, весь код, что мы будем писать в этом семестре должен прекрасно работать под Linux и под macOS. В основном разработка на C\# ведётся в Microsoft Visual Studio (Community Edition бесплатна и её вполне достаточно для всех практических целей), также хорош Rider IDE от JetBrains (\url{https://www.jetbrains.com/rider/}), он кроссплатформенный и работает на чём угодно, к тому же бесплатный для студентов. Есть ещё Visual Studio Code, которая работает под Linux и macOS, и с плагинами для поддержки C\# в целом не сильно хуже настоящих IDEшек.

C\# называется <<си шарп>> примерно по тем же причинам, почему С++ называется С++ --- диез в музыке указывает на то, что ноту следует играть на полтона выше, так же как ++ --- оператор инкремента. C\# можно рассматривать как развитие C++, при этом C\# имеет ряд особенностей, которыми он радикально отличается от C/C++. Самая главная особенность, пожалуй, это использование виртуальной машины. Как происходит исполнение программы, написанной на C или C++ --- исходный код компилируется сразу в исполнимый код, который линкуется в исполняемый файл, который может быть загружен в память и исполнен той операционной системой, для которой он предназначается. Другая операционная система скомпилированную программу исполнить не сможет. В C\# принцип работы совсем другой, C\# --- один из языков, совместимых с так называемой Common Language Infrastructure. Его исходный код компилируется в последовательность команд некоей абстрактной машины (в т.н. байт-код .NET), которая потом интерпретируется специальным приложением --- дотнет-машиной. Дотнет-машина должна быть реализована для каждой операционной системы, на которой нужно запускать приложения на C\#, зато, поскольку система команд машины стандартизована (это тоже международный стандарт, предложенный Майкрософт и реализованный в .NET и Mono, независимой открытой реализации, не связанной поначалу с Microsoft), это теоретически позволяет исполнять C\#-приложение под любой операционной системой, для которой есть дотнет-машина (такой принцип называется <<скомпилированное однажды, запускается везде>> (compile once, run anywhere), в отличие от переносимости на уровне исходных кодов <<write once, run anywhere>>). Схематично такой подход можно изобразить так:

\begin{center}
    \includegraphics[width=0.6\textwidth]{cli.png}
\end{center}

Изначально .NET Framework работал, однако, только под Windows, был проприетарным и вообще создавался как замена WinAPI для написания программ под Windows. Однако когда .NET начал существенно проигрывать в популярности Java, Microsoft выложил исходники довольно большой части .NET (в том числе, исходники компилятора C\# и основных библиотек), на это всё можно посмотреть на GitHub (\url{https://github.com/dotnet}). Однако изначально CLI (собственно, стандартизация байт-кода, дотнет-машины и библиотек поддержки) создавалась не для обеспечения переносимости, (которая была не очень-то выгодна Microsoft, имевшей в начале двухтысячных амбиции иметь большую долю рынка и серверных ОС тоже), а для того, чтобы иметь несколько языков программирования, работающих с одними библиотеками в одинаковой среде. Кроме C\#, в байт-коды дотнет-машины компилируется Visual Basic, J\# (ныне покойный), F\#, ещё куча всяких языков, созданных уже не Microsoft (например, Delphi с версии 8 умел компилироваться в байт-код .NET) --- наличие единого байт-кода и виртуальной машины, его исполняющей, фактически избавляет от необходимости писать часть компилятора, относящуюся к низкоуровневой оптимизации и генерации машинного кода, уменьшая работу по созданию компилятора минимум на треть, и заодно делая все языки бинарно совместимыми совершенно даром. Бинарная совместимость означает, что код, написанный на одном языке (функция, процедура, класс, и т.д.), может быть безболезненно использован в программах, написанных на другом языке. Это очень удобно, поскольку <<отвязывает>> библиотеки от языка реализации, можно писать библиотеки на чём угодно, и легко ими пользоваться, и даже в одном проекте можно писать код на разных языках. 

Кроме того, дотнет-машина может следить за выполнением программы более строго, чем операционная система --- за выполнением <<native>>-программы, например, сразу же обнаружить попытку чтения или записи в чужую область памяти, выход за границы массива и т.д. Кроме того, переменные сами инициализируются, исполняемая программа имеет в себе кучу отладочной информации, и вообще, жизнь программиста делается более простой и приятной.

За такое удобство приходится платить падением скорости работы программы --- ведь интерпретировать инструкцию гораздо дороже, чем просто исполнить её на процессоре. Однако с этим научились бороться, с помощью техники, называемой Just-In-Time-компиляцией. JIT-компиляция --- это когда последовательность инструкций байт-кода переводится в машинный код прямо в процессе выполнения программы, после чего запоминается для последующего использования. При этом дотнет-машина может использовать для оптимизации информацию, недоступную <<статическим>> компиляторам --- например, в процессе работы смотреть, какая функция вызывается чаще, и делать для неё инлайн-подстановку. Так что в целом, хоть хорошо написанные программы на C и С++, скорее всего, будут работать быстрее, дотнет-машина может выигрывать в производительности у плохо написанных программ на C или С++, и, поскольку время работы программиста сейчас гораздо дороже, чем время работы программы (как правило), приложения всё больше пишут на C\# (ну или Яве).

Следует отметить, что виртуальную машину в качестве среды выполнения использует далеко не только C\# (ну, в смысле, языки CLI, их много) --- программы на Яве или Котлине тоже исполняются Java-машиной, идея виртуальной машины была предложена ещё Виртом для языка Паскаль (в 70-х годах 20-го века, так что это не суперновая технология). Причём в код Java-машины тоже можно компилировать не одну только Java --- есть ещё языки, типа Скалы, и Котлина, ориентирующиеся на Java-машину как среду выполнения, или Ада --- которая имеет компилятор в байт-код Java помимо нативного кода.

Следующим важным отличием C\# от C является сборка мусора. В С надо было следить за выделением памяти --- память, выделенную в куче, надо было освобождать вручную. В C\# выделять память надо, а освобождать --- нет, это сделает сама дотнет-машина, точнее, сборщик мусора (garbage collector). Дотнет-машина следит за тем, на какие области памяти ссылается программа, и если есть выделенная область памяти, на которую не ссылается больше никто, она её удалит. Опять же, это не особенность .NET, Java-машина поступает так же, а сама идея сборки мусора предлагалась ещё в лиспе, в 1959. Концептуально сборка мусора работает так: все области памяти помечаются как <<ненужные>>, потом все переменные на стеке вызовов помечаются как <<нужные>>, потом все области памяти, на которые указывают переменные на стеке вызовов или их поля помечаются как <<нужные>>, потом все области памяти, на которые указывают <<нужные>> области памяти, помечаются как нужные и т.д., пока не останется указателей, на которые мы ещё не смотрели. Те области памяти, которые остались помечены как <<ненужные>>, очищаются (это алгоритм mark-and-sweep). Картинка из википедии, поясняющая суть:

\begin{center}
    \includegraphics[width=0.4\textwidth]{markAndSweep.png}
\end{center}

В реальности используются более сложные алгоритмы, поскольку, во-первых, сборка мусора --- это вычислительно сложная операция (средняя игра занимает в памяти до 8Гб, ходить по ней всей фактически поиском в ширину сложновато), во-вторых, требуется остановка приложения (иначе если память будет выделена или освобождена в процессе работы сборщика мусора, всё умрёт). Так что используются поколения, параллельная сборка мусора, оптимизации типа Large Object Heap и т.д. Сейчас важно понимать, что про malloc/free в C\# можно забыть, как про страшный сон. Естественно, организовать себе утечку памяти можно даже в C\#, но это гораздо сложнее сделать случайно, для этого даже потребуется некоторое продвинутое знание языка. Что интересно, что благодаря тому, что выделение памяти выполняется виртуальной машиной из заранее выделенного пула памяти, причём это делается за константное время, программа, активно использующая кучу, на C\# может работать быстрее, чем на C (впрочем, современные компиляторы C/C++ используют оптимизации, похожие на то, что делается в C\#, так что кто победит трудно сказать заранее).

\section{Технические детали}

Собственно, традиционная программа <<Hello, world>>:

\begin{minted}{csharp}
System.Console.WriteLine("Goodbye, cruel world!");
\end{minted}

И всё, да. Это так называемый синтаксис операторов верхнего уровня, появившийся только в C\# 9. Более традиционный вариант той же самой программы (как и надо было писать до C\# 9, но и в новом C\# это, конечно, работает):

\begin{minted}{csharp}
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Goodbye, cruel world!");
        }
    }
}
\end{minted}

Что мы тут видим: во-первых, работающая программа на C\#, как и на любом другом объектно-ориентированном языке, представляет собой набор объектов, взаимодействующих друг с другом через чётко определённые интерфейсы посылкой и приёмом сообщений. Тип объекта --- это класс, т.е. класс описывает структуру и поведение объектов. Код программы на C\# представляет собой набор классов, классы организованы в нэймспейсы, свободных функций (не методов класса) в C\#, в отличие от C++, на самом деле не бывает вообще. Код из C\# 9, показанный выше, тоже на самом деле компилируется в класс (если интересны технические подробности, с именем \mintinline{text}{$Program}). Нэймспейс --- это такое средство группировки: в одном нэймспейсе лежат связанные логически классы (ну, и другие типы), неймспейсы могут быть вложенными, позволяя создавать такую иерархическую структуру. Кстати, разделения на хедеры и c-шники в C\# нет, всё, что относится к одному классу, пишется в одном файле, с расширением .cs. Есть, правда, возможность определять класс в нескольких разных файлах, через partial-классы, но это нужно для некоторых специальных целей, про которые потом. Считается хорошим тоном поддерживать соответствие <<один файл --- один класс>>. Так вот, каждый класс относится к некоторому неймспейсу, неймспейс можно и не писать, тогда класс будет считаться принадлежащим нэймспейсу по умолчанию, но это дурной тон. Одноимённые классы из разных неймспейсов можно различить, указывая \textit{квалифицированное имя} класса: <имя нэймспейса>.<имя класса>. Кроме нэймспейса, есть ещё понятие <<сборка>> (assembly) --- это отдельный проект, кусок кода, который собирается в отдельный .exe или .dll-файл. Один неймспейс может определяться в разных сборках, и одна сборка может иметь много неймспейсов, но тем не менее, сборки тоже работают как некое средство группировки, потому что позволяют управлять видимостью классов друг другу --- можно сделать класс видимым только внутри своей сборки, а можно сделать его видимым и в других сборках тоже (типа интерфейса сборки). Вообще, создавать отдельные библиотеки и использовать их в проекте очень легко, в отличие от C, так что приложение на C\# (ну или вообще любом дотнет-языке), как правило, состоит из большего числа отдельно собираемых модулей, чем С. Кстати, подключение неймспейса делается с помощью ключевого слова using, так что using System --- это подключение неймспейса System, почти как \#include в C. На самом деле нет, компилятор C\# и так видит все объявленные классы во всех исходниках и всех подключённых библиотеках, так что \#include не нужен вовсе. Видны все public-классы всех сборок, подключённых к данному проекту, во всех файлах проекта, а классы проекта видны в других файлах проекта вообще всегда, что по сравнению с C сказочно удобно.

Дальше мы видим объявление класса Program. Внутри фигурных скобочек находятся объявления полей, методов и свойств класса, вложенных классов, перечислений и т.д. В нашем случае в классе есть только метод Main, он static --- то есть он является методом класса, в противоположность обычным методам, которые относятся к конкретному объекту. Методы класса не используют данные, хранящиеся в объекте, так что наличие объекта им не нужно для работы. Это самое близкое, что есть в C\# к обычным сишным функциям, которыми вы пользовались в прошлом семестре. Он имеет тип возвращаемого значения void, то есть, как и в C, это означает, что он не возвращает ничего. Заметим, что в отличие от С C\#-овая <<функция>> Main код возврата сама не должна возвращать. Эта функция принимает один параметр --- массив строк (то есть, объектов класса String, представляющих строки, про сишные char*, развлечения с указателями и всякие соглашения типа того, что строка кончается на 0, можно забыть, как страшный сон. То есть внутри оно всё так и есть, но хорошо скрыто, что, в частности, является преимуществом объектно-ориентированного программирования). Аналог C\#-ового String – С++-ный std::string. Массивы в C\# тоже не так просты, как в С, а представляют собой объекты, с полями и методами, например, у них есть свойство Length, которое содержит длину массива.

Дальше стоит вызов метода WriteLine класса Console. Он, как и следовало ожидать, печатает на консоль строку и переводит строку. У Console есть ещё много всяких полезных методов, например, Beep, и ещё больше всяких свойств, типа ForegroundColor (и BackgroundColor), и Title. Есть ещё метод Write, который делает то же, что и WriteLine, но не переводит строку. Заметьте, WriteLine может выводить всё без всякой форматной строки, но если нужна форматная строка, тоже ок: \mintinline{csharp}|Console.WriteLine("Hello, {0}!", "world");| или даже так: \mintinline{csharp}|var name = "world"; Console.WriteLine($"Hello, {name}!");|. Заметьте, никаких форматных спецификаторов не надо, C\# сам догадывается о типе выводимых параметров.

Синтаксис тел методов весьма похож на C, так что скорее всего получится просто сесть и начать писать код так, будто бы это был С. Например, цикл for:

\begin{minted}{csharp}
for (int i = 0; i < 300; ++i)
{
    Console.WriteLine("Мат-мех лучше всех!");
}
\end{minted}

или так: 

\begin{minted}{csharp}
for (var i = 0; i < 300; ++i)
{
    Console.WriteLine("Мат-мех не для всех!");
}
\end{minted}

Заметьте, для работы с русскоязычными строками не надо никаких setlocale или управления кодировками --- все строки в C\# всегда в Unicode, а все символы двухбайтовые.

Тут показана интересная фича C\# --- частичный вывод типов. i инициализируется интовой константой 0, так что компилятор знает, что тип переменной i должен быть интом (иначе типы не сойдутся), так что это можно не указывать и писать вместо имени типа var. Тут, правда, есть идеологический спор по поводу того, как часто надо использовать var. Некоторые говорят, что var использовать нельзя, потому что явные аннотации типов накладывают дополнительные ограничения на программу, и тем самым уменьшают вероятность ошибок и делают программу гораздо более читабельной. Некоторые говорят, что var надо использовать всегда, поскольку информация о типе избыточна и до тех пор, пока компилятор может вывести тип, не несёт семантической нагрузки, к тому же короткое var в коде выглядит гораздо лучше, чем какое-нибудь System.Collections.Generic.Dictionary<string, int>, так что использование var делает программу гораздо более читабельной. Некоторые занимают промежуточную позицию и предпочитают использовать var только чтобы не писать длинных имён типов. Лично я люблю var, и предлагаю вам им активно пользоваться, хотя бы в тех случаях, когда тип переменной очевиден из правой части присваивания (например, \mintinline{csharp}{var str = new String("s");}). Кстати, в среде даже опытных программистов распространена ересь, что var ломает строгую типизацию, делая тип переменной <<неопределённым>> --- это неправда, тип переменной в любом случае точно известен во время компиляции, ломает типизацию другая штука --- dynamic, но про неё лучше забудьте прямо сейчас.

Функции задаются, например, так:

\begin{minted}{csharp}
private static int Factorial(int n)
{
    if (n == 1)
    {
        return 1;
    }

    return n * Factorial(n - 1);
}
\end{minted}

--- это нужно писать в классе Program на том же уровне, что и функция Main. Использовать из функции Main, например, так:

\begin{minted}{csharp}
Console.WriteLine(Factorial(4));
\end{minted}

Кстати, компилятор многопроходный, поэтому ему плевать, выше или ниже функции Main описана наша функция.

В современном C\# функции, тело которых состоит из одной строчки, можно писать вообще в одну строку, без фигурных скобок, вот так:

\begin{minted}{csharp}
private static int Factorial(int n) 
    => n <= 1 ? 1 : n * Factorial(n - 1);
\end{minted}

Это называется Expression-bodied method, и когда мы дойдём до рассказа про лямбда-функции, будет понятно, почему оно так выглядит. Это на самом деле синтаксический сахар для того, чтобы писать программы кратко и красиво (хотя такой синтаксис может быть непривычен сишникам).

Обратите внимание на некоторые особенности местного стайлгайда. Вообще, стайлгайд тут не как в С, где пишут кто как умеет, а определяется исходниками от Майкрософт, так что довольно строгий (ну, вариации есть, но некоторые правила вообще общеприняты). Имена методов и свойств пишутся всегда с заглавной, имена полей всегда со строчной. Тела составных операторов, типа if-ов, считается хорошим тоном всегда оборачивать в фигурные скобки, но этому следуют не всегда. То же касается отделения закрывающей фигурной скобки пустой строкой от кода ниже. Некоторые правила стайлгайда Visual Studio применяет автоматически и без спроса, так что не удивляйтесь, если вы пишете как обычно, а получается всё равно хорошо. Есть даже плагин к Visual Studio (и отдельный анализатор, подключаемый к проекту), который выдаёт предупреждения при нарушении общепринятого стайлгайда, \url{https://github.com/DotNetAnalyzers/StyleCopAnalyzers}. Очень рекомендую, хотя часть предупреждений придётся отключить, особенно поначалу (например, подписывать сборки мы не будем).

\section{Типы данных}

С типами данных в C\# ситуация несколько отличается от C. Во-первых, размеры элементарных типов данных стандартизованы, так что если число байт, выделяемых под int в C зависело от реализации, то в C\# это ровно 32 байта, даже если мы запускаем программу на микроволновке с 16-битным процессором. Во-вторых, что даже более важно, каждый тип данных в C\# --- это класс, даже int наследуется от класса System.Object и имеет методы. Хорошая новость в том, что это на прикладных программистов особо не влияет (даже делает более удобной работу с элементарными типами) --- int-ы всё так же располагаются на стеке вызовов и копируются при присваивании. Подробности про это на следующей паре.

Каждый элементарный тип имеет своё ключевое слово, как в С, и ещё имя типа, объявленное в библиотеке Base Class Library (неймспейс System), которое его синоним. Так что string и System.String --- это одно и то же.

У каждого типа есть значение по умолчанию, которым его переменные инициализируются сразу при объявлении. Неинициализированных переменных, с которыми приходилось бороться в C, в C\# просто не бывает (хотя компилятор будет ругаться, если, например, пытаться передать как параметр локальную переменную, которой не было присвоено значение). Вообще, компилятор внимательно анализирует поток данных и выдаёт ошибку, если ему кажется, что что-то не так.

У типов-синонимов есть полезные статические методы, которые есть и у, мм, ключевых слов, им соответствующих. Например, как преобразовать строку в число:

\begin{minted}{csharp}
var inputString = Console.ReadLine();
int number = Int32.Parse(inputString);
\end{minted}

Это то же самое, что и

\begin{minted}{csharp}
var inputString = Console.ReadLine();
int number = int.Parse(inputString);
\end{minted}

В общем-то, с ООП все должны быть хотя бы примерно знакомы, но для программистов на чистом C это выглядит диковато.

Массивы:

\begin{minted}{csharp}
int[] a = new int[10];
\end{minted}

или

\begin{minted}{csharp}
var a = new int[10];

for (var i = 0; i < a.Length; ++i)
{
    a[i] = i;
}
\end{minted}

Тут всё как обычно, единственное, что массивы всегда размещаются на куче (то есть без ключевого слова new создать массив нельзя), квадратные скобочки пишутся после типа, а не после переменной, как в C, и главное, массив --- это объект (имеющий, например, свойство Length, в котором хранится его длина, поэтому передавать длину вместе с массивом больше не надо). Для тех, кто в курсе, очевидна аналогия с std::vector.

Многомерные массивы:

\begin{minted}{csharp}
int[,] numbers = new int[3, 3];
numbers[1,2] = 2;
 
int[,] numbers2 = new int[3, 3] { {2, 3, 2}, {1, 2, 6}, {2, 4, 5} };
\end{minted}

Обратите внимание, что C\# поддерживает именно многомерные массивы, а не массивы массивов, как в C. Массивы массивов тоже никто не запрещает:

\begin{minted}{csharp}
int[][] a = new int[3][];
a[1][2] = 0;
\end{minted}

--- так программа упадёт (угадайте почему), а вот так будет работать:

\begin{minted}{csharp}
int[][] a = new int[3][];
for (int i = 0; i < 3; ++i)
{
    a[i] = new int[3];
}

a[1][2] = 0;
\end{minted}

Структуры:

\begin{minted}{csharp}
struct Point
{
    public int x;
    public int y;
}
\end{minted}

Обратите внимание, что видимость по умолчанию у полей структуры такая же, как и у полей класса --- private, так что приходится писать public, чтобы они были доступны извне. А ещё в отличие от С++ писать модификатор видимости надо перед каждым полем и методом (ну, необязательно, но тогда видимость будет по умолчанию, и хорошим тоном считается модификатор видимости писать, даже если умолчание нас устраивает). Про всё это будет подробнее на следующей паре, структуры не так просты, как кажутся, но использовать их можно так же, как в C++.

Есть типы-перечисления:

\begin{minted}{csharp}
enum SomeEnum
{
    red,
    green,
    blue
}
\end{minted}

Использование:

\begin{minted}{csharp}
SomeEnum a = SomeEnum.blue;
\end{minted}

или так:

\begin{minted}{csharp}
var a = SomeEnum.blue;
\end{minted}

Обратите внимание, что имя енума должно предшествовать имени значения всегда, енум образует что-то вроде неймспейса для своих значений (как enum class в C++, если кто в курсе).

Константы задаются с помощью ключевого слова const, как в С++ и частично в C (но не как в Яве, где для этого есть ключевое слово final).

Всякие математические штуки находятся в классе Math неймспейса System. Например, Math.Cos(1); --- раз свободных функций в языке нет, функции на самом деле не функции, а статические методы. Хорошая новость в том, что есть using static, так что префикс Math можно не писать (особенно, если погуглить, что такое using static, и начать его использовать).

\section{Инструменты разработки}

Есть бесплатная Visual Studio Community 2022, которую можно скачать с \url{https://www.visualstudio.com/}, есть бесплатный для студентов Rider, который работает и под виндой, и под линуксом, и под маком (правда, пока не умеет дизайнить формочки в приложениях с графическим интерфейсом, но формочки можно описывать и напрямую в коде, так что это не страшно). Оправдания типа <<Я пытался сделать домашку на GtkSharp, оказалось, что он не умеет <подставить нужное>, а разобраться в WinForms я уже не успею>> на зачёте приниматься не будут. Создать проект в Visual Studio можно через New Project -> C\# -> Console App (.NET Core), линуксоиды сами, я надеюсь, разберутся. Ещё на Visual Studio можно поставить ReSharper (это плагин от JetBrains, бесплатный для студентов), программировать станет в разы приятнее, но только если ваше железо позволяет (он довольно ресурсоёмок и может заставить студию подтормаживать). Rider умеет то же, что и ReSharper, но, как говорят, не тормозит.

\end{document}

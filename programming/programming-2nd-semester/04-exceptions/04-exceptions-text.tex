\documentclass[a5paper]{article}
\usepackage[a5paper, top=8mm, bottom=8mm, left=8mm, right=8mm]{geometry}

\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}

\usepackage{fontspec}
\setmainfont{FreeSerif}
\newfontfamily{\russianfonttt}[Scale=0.7]{DejaVuSansMono}

\usepackage[font=scriptsize]{caption}

\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\usepackage{cite}
\usepackage{textcomp}
\usepackage{forest}

\usetikzlibrary{arrows}

\usepackage[hang,multiple]{footmisc}
\renewcommand{\footnotelayout}{\raggedright}

\PassOptionsToPackage{hyphens}{url}\usepackage[xetex,linktocpage=true,plainpages=false,pdfpagelabels=false]{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}

\newlength\Colsep
\setlength\Colsep{10pt}

\usepackage{tabu}

\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{footnote}
\usepackage{minted}

\newcommand{\todo}[1] {
\begin{center}\textcolor{red}{TODO: #1}\end{center}
}

\sloppy
\pagestyle{plain}

\title{Исключения и обработка ошибок}
\author{Юрий Литвинов\\\small{yurii.litvinov@gmail.com}}

\date{10.03.2022}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Исключения, бросание исключений}

Часть ошибок ловится на этапе компиляции, однако с остальными так или иначе приходится иметь дело во время выполнения. Каждый язык имеет свои механизмы и средства для обнаружения и обработки ошибочных ситуаций. В C, например, это было соглашение о возвращаемых функциями значениях + переменная errno, по которой можно было узнать о том, что же конкретно произошло. Недостатки данного подхода:

\begin{itemize}
    \item это не особенность языка или среды, а лишь соглашение между разработчиками, на которое при желании вполне можно забить;
    \item можно забыть или не знать о каких-то особенностях возвращаемых значений;
    \item если проверять значение, возвращаемое каждым вызовом, читаемость кода резко падает.
\end{itemize}

Создавать большие, надежные и в то же время простые системы с таким подходом очень сложно.

Концепция обработки исключений начала зарождаться еще в 60-х годах с развитием операционных систем или даже с появлением в бейсике операции goto. Исключения в C\# работают идеологически так же, как и исключения в Java, которые основаны на исключениях C++, которые в свою очередь берут начало от исключений языка Ada.

В том месте, где случилось что-то нехорошее, мы можем и не знать, что же с этой ситуацией делать. Но продолжать работу дальше нельзя --- кто-то где-то (если не в этом контексте, то где-то выше, например, в вызывающем методе внешнего объекта) обязан сделать что-то с имеющейся ситуацией. Но не каждая ошибка должна генерировать исключение. Общая рекомендация такова, что исключительными являются ситуации, которые мы не можем обработать в данном контексте. В таком случае необходимо передать управление и ответственность за разрешение этой проблемы обработчику исключений. Например, перед операцией деления можно проверить, не является ли делитель нулем. Но что значит нулевой делитель в данном контексте? Нарушено ли какое-то важное правило бизнес-логики, или это можно как-то локально исправить и пойти дальше?

Когда генерируется (бросается) исключение, на куче создается специального вида объект и управление передается обработчику исключений, назначение которого заключается в обработке подобных ситуаций и восстановлении корректности внутреннего состояния программы. Например, у нас есть ссылка на некий объект t, и мы хотим убедиться, что она была проинициализирована.

\begin{minted}{csharp}
if (t == null)
{
    throw new NullReferenceException();
}
\end{minted}

На самом деле дотнет-машина сама умеет бросать это исключение (как и многие другие), и каждую ссылку проверять не нужно. Если исключение не поймать, программа аварийно завершится (``упадёт''), и пользователю покажут окошко с предложением отправить отчёт об ошибке разработчикам, или что-то вроде, в зависимости от ОС. 

У объектов исключений обычно есть 3 конструктора --- конструктор по умолчанию, конструктор с одним строковым аргументом, в котором можно передать сообщение, конкретизирующее произошедшее, и конструктор, принимающий помимо сообщения ещё внутреннее исключение. Про внутренние исключения будет немного позже, пока вот пример использования второго конструктора:

\begin{minted}{csharp}
throw new NullReferenceException("Something is very wrong");
\end{minted}

Это сообщение, если исключение останется необработанным, потом может быть показано пользователю в каком-нибудь окошке, или, если исключение обработать, записано в лог, или ещё куда-нибудь.

Ключевое слово throw инициирует следующие события:

\begin{itemize}
    \item создается объект-исключение;
    \item этот объект неким образом ``возвращается'' из метода, хотя тип возвращаемого значения метода, естественно, другой, выполнение метода прерывается;
    \item на стеке ищется метод, содержащий обработчик для данного типа исключений, управление передаётся обработчику, все методы между методом, бросившим исключение, и методом, ``поймавшим'' исключение, также прерываются;
    \item если обработчика так и не нашлось и исключение распространилось за Main, вся программа прерывается.
\end{itemize}

Так что механизм бросания исключений в некотором смысле можно рассматривать как аналогию механизма возврата значений (однако, на этом сходство заканчивается, т.к. при генерации исключения мы попадаем совсем в другое место, которое может быть очень далеко от места ошибки). throw в каком-то смысле можно понимать как return, вот только использовать его для обычного возврата значений --- плохая идея.

В общем-то, бросить можно объект любого класса, унаследованного от класса Exception (корневого класса иерархии исключений .NET), или даже прямо его (\mintinline{csharp}|throw new Exception(``Something wrong'');| тоже вполне ок), но хорошим стилем является создание отдельного класса ошибки для каждого типа исключительных ситуаций. Так обработчик исключения по типу и информации, хранящейся в объекте, сможет понять, что же произошло. Собственно, почему так, будет понятно, когда мы рассмотрим, как ловить исключения. 

\section{Обработка исключений}

Для того, чтобы исключения ловить, разберем понятие ``охраняемой области'' (guarded region). Если бросить исключение внутри метода, то произойдет выход из этого метода. Если же мы хотим остаться внутри этого метода, нужно поместить ``опасный код'' внутрь блока try. В языках, не поддерживающих механизмы исключений, по сути вы обязаны помещать каждый вызов функции в аналог такого блока (проверка и действия при некорректном значении). Здесь же нужен только один такой блок, это разграничивает основной, ``функциональный'' код и действия, которые должны осуществляться, если что-то пошло не так.

Блок обработки исключений должен идти сразу же за блоком try:

\begin{minted}{csharp}
try
{
    // Код, который может бросать исключения
}
catch (Type1 id1)
{
    // Обработка исключения типа Type1
}
catch (Type2 id2)
{
    // Обработка исключения типа Type2
}
catch (Type3 id3)
{
    // Обработка исключения типа Type3
}
finally
{
    // Код, который исполняется всегда, было брошено исключение или нет
}
\end{minted}

Каждый catch --- это как отдельный метод с единственным аргументом, типа ожидаемого исключения. При возникновении исключения обработчики просматриваются по порядку и управление передается первому, тип аргумента которого совпадает с типом объекта исключения (с учетом наследования классов, то есть сам тип и все его наследники подойдут). Из этого, кстати, следует, что типы исключений надо располагать от более частного к более общему, иначе поймается общим обработчиком, а у частного даже не будет шансов (в C\# это, кстати, ошибка компиляции). Из этого же следует, что чтобы поймать все исключения вообще, надо ловить по типу Exception, поскольку от него наследуются все остальные (и, разумеется, располагать его в самом низу последовательности catch-ей).

Каждый блок catch можно понимать как функцию, которая принимает параметром объект-исключение указанного типа и ничего не возвращает. Нахождение нужного обработчика путём сопоставления реального объекта-исключения с типами-исключениями, принимаемыми обработчиками, сродни такому понятию функционального программирования, как сопоставление шаблонов (pattern matching). Это, кстати, приводит к тому, что исключения, определяемые в программе, как правило, никакой содержательной информации, кроме собственно своего типа, не имеют. Тем более, не бывает исключений, имеющих содержательные методы, поэтому пугаться класса, у которого есть один конструктор, и всё, не следует --- он нужен лишь как объект для сопоставления с шаблоном в обработчиках.

Блок finally содержит в себе код, который будет исполняться вне зависимости от того, какой обработчик события сработал (и было ли исключение вообще). В языках без сборки мусора блок finally предназначен для того, чтобы закрыть все ресурсы и освободить выделенную память. Память в C\# освобождается сборщиком мусора, однако все остальные ресурсы, такие как файлы и сетевые соединения, на вашей совести. 

Вот небольшой пример работы с исключениями при чтении из файла:

\begin{minted}{csharp}
private void ReadData(String pathname) 
{
    FileStream fs = null;
    try 
    {
        fs = new FileStream(pathname, FileMode.Open);
        // Делать что-то полезное
    }
    catch (IOException) 
    {
        // Код восстановления после ошибки
    }
    finally 
    {
        // Закрыть файл надо в любом случае
        if (fs != null) 
        {
            fs.Close();
        }
    }
}
\end{minted}

Тут мы внутри охраняемой области создаём поток, позволяющий читать из файла или писать в файл, что-то с ним делаем, и если произошло какое-то исключение, связанное с файлом, мы что-то делаем (например, пишем сведения об исключении в лог и заканчиваем работу). В любом случае в блоке finally мы закрываем файл. На самом деле, так делать не надо, потому что есть блок using, который закроет файл сам даже в случае исключения, но про это чуть попозже.

Ещё в catch может быть фраза when, которая позволяет фильтровать исключения в зависимости от их свойств или вообще от состояния системы (после when может быть любое булевое выражение). Вот пример:

\begin{minted}{csharp}
public static string MakeRequest()
{
    try
    {
        var request = WebRequest.Create("http://se.math.spbu.ru");
        var response = request.GetResponse();
        var stream = response.GetResponseStream();
        var reader = new StreamReader(stream);
        var data = reader.ReadToEnd();
        return data;
    }
    catch (WebException e) 
        when (e.Status == WebExceptionStatus.ConnectFailure)
    {
        return "Connection failed";
    }
}
\end{minted}

Этот кусок кода скачивает HTML-страницу с сайта \url{http://se.math.spbu.ru}, и, если произошло исключение работы с сетью, которое в свойстве Status имеет WebExceptionStatus.ConnectFailure, мы возвращаем строку, означающую, что соединение не установлено. Этот пример на самом деле тоже неправильный, потому что соединение не закрыто, но правильно писать через using, а про это немного потом.

\section{Иерархия классов-исключений}

Все исключения в .NET объекты (как и всё в .NET), поэтому они все наследуются от Object. Исключения --- ссылочные типы, поэтому выделяются на куче (поэтому бросать новое исключение в обработчике OutOfMemory может быть плохой идеей). Все исключения наследуются от класса System.Exception, от которого в библиотеке .NET наследуются два класса: SystemException и ApplicationException. Изначально идея была такой, что от SystemException наследуются только исключения, бросаемые стандартной библиотекой, а от ApplicationException наследуются все пользовательские исключения. Это давало бы возможность ловить ApplicationException и знать, что это исключение, которое точно бросили мы, и ловить SystemException зная, что это бросили не мы, что означает аварийную ситуацию или ошибку кодирования.

Однако такое разделение оказалось не очень полезно, потому как в пользовательском коде рекомендовалось бросать библиотечные исключения (наследников SystemException), такие как IndexOutOfRangeException, а библиотека иногда сама кидала наследников ApplicationException. Поэтому сейчас рекомендуется не заморачиваться и наследовать свои исключения прямо от Exception, ApplicationException использовать не рекомендуется вовсе.

Вот картинка с иерархией некоторых исключений в .NET:
\begin{center}
    \begin{tiny}
        \begin{forest}
            for tree={rectangle,draw,l sep=1cm,s sep=3mm,edge=open triangle 60-}
            [Object
                [Exception
                    [SystemException
                        [IndexOutOfRangeException]
                        [NullReferenceException]
                        [StackOverflowException]
                        [ArgumentException
                            [ArgumentNullException]
                            [ArgumentOutOfRangeException]
                            [\dots]
                        ]
                    ]
                    [ApplicationException]
                ]
            ]
        \end{forest}
    \end{tiny}
\end{center}

\section{Свойства исключений}

Объекты, унаследованные от Exception, имеют следующие полезные свойства:

\begin{itemize}
    \item Data --- коллекция пар ключ/значение, в которой может лежать любая дополнительная информация об исключении. На самом деле, не нужна, потому что бросать надо по возможности свои исключения, а в своих исключениях можно определить нормальные поля и свойства с этой самой дополнительной информацией;
    \item HelpLink --- ссылка на страницу с информацией об исключении. Чтобы тот, кто с этим исключением столкнулся, знал, куда смотреть.
    \item InnerException --- информация о предыдущем исключении, которое привело к возникновению текущего. Чуть дальше будет про перебрасывание исключений, будет понятно, что это и зачем.
    \item Message --- текстовое описание исключения.
    \item Source --- информация о месте, где возникло исключение (название сборки или класса). В общем-то не очень полезно, потому что есть более интересное свойство StackTrace.
    \item StackTrace --- распечатка стека вызовов до места возникновения исключения. По нему можно понять, кто кого вызывал и где именно всё упало, очень полезно при отладке.
    \item HResult --- свойство, выставляемое некоторым исключениям, которые были кинуты из нативного кода ``под'' библиотекой .NET, это что-то вроде кода ошибки. Нужно это прежде всего для взаимодействия с COM-объектами, а так как COM-объекты --- это что-то из конца 90-х, то уже особо и не нужно.
\end{itemize}

Небольшой пример:

\begin{minted}{csharp}
try
{
    throw new Exception("Something is very wrong");
}
catch (Exception e)
{
    Console.WriteLine("Caught Exception");
    Console.WriteLine("e.Message: " + e.Message);
    Console.WriteLine("e.ToString(): " + e.ToString());
    Console.WriteLine("e.StackTrace:\n" + e.StackTrace);
}
\end{minted}

Вывод в данном случае будет:

\begin{minted}{text}
Caught Exception
e.Message: Something is very wrong
e.ToString(): System.Exception: Something is very wrong
   в CSharpConsoleApplication.Program.Main(String[] args) в c:\Users\yurii_000\D
ocuments\Visual Studio 2012\Projects\CSharpConsoleApplication\CSharpConsoleAppli
cation\Program.cs:строка 15
e.StackTrace:
   в CSharpConsoleApplication.Program.Main(String[] args) в c:\Users\yurii_000\D
ocuments\Visual Studio 2012\Projects\CSharpConsoleApplication\CSharpConsoleAppli
cation\Program.cs:строка 15
Для продолжения нажмите любую клавишу . . .
\end{minted}

\section{Перебрасывание исключений}

Допустим, мы в обработчике исключения посмотрели на текущую ситуацию и поняли, что сами мы разобраться с ошибкой не можем и её надо отправить вверх по стеку. Или мы что-то сделали, но всё равно хотим, чтобы исключение попало в обработчик, который выше по стеку. Тогда мы можем, во-первых, бросить то же исключение, во-вторых, бросить новое исключение, при желании передав ему как внутреннее исключение (свойство InnerException) наше исключение, которое мы поймали. Эти способы принципиально отличаются тем, что новый объект-исключение не будет помнить истории старого объекта (StackTrace, например), а если бросить старый объект, то его StackTrace останется неизменным (словно его никто не ловил). Перебрасывать старое исключение, например, так:

\begin{minted}{csharp}
try
{
    throw new Exception("Something is very wrong");
}
catch (Exception e)
{
    Console.WriteLine("Caught Exception");
    throw;
}
\end{minted}

Новый объект-исключение можно бросить так:

\begin{minted}{csharp}
try
{
    throw new Exception("Something is very wrong");
}
catch (Exception e)
{
    Console.WriteLine("Caught Exception");
    throw new Exception("Outer exception", e);
}
\end{minted}

Ситуация с броском нового объекта кажется довольно экзотичной, но весьма часто используется в дотнетовских библиотеках, так что прежде чем говорить ``оно просто упало, и я не могу понять почему'', имеет смысл посмотреть поле InnerException, там может быть написано, что именно пошло не так. Делается это, чтобы не ловить, например, тысячу разных исключений из базы данных, а одно исключение ``в базе данных что-то не так'', и потом уже с ним разбираться, смотря на его поле InnerException.

\section{Создание своих классов исключений}

Свои классы-исключения имеет смысл создавать всегда, когда вы хотите сообщить об ошибке, кроме каких-то распространённых случаев типа неправильного аргумента или некорректного состояния объекта (хотя даже в этих случаях может иметь смысл сделать свой класс-исключение). Наследовать своё исключение надо от наиболее подходящего библиотечного класса-исключения, либо прямо от Exception, если подходящего класса не нашлось. Выглядеть всё это будет примерно так:

\begin{minted}{csharp}
public class MyException : Exception
{
    public MyException() 
    {
    }

    public MyException(string message)
        : base(message)
    {
    }
}
\end{minted}

Обратите внимание, что исключения довольно часто оказываются вне сборки, в которой объявлены, так что весьма желательно их делать public. Более того, исключения довольно часто оказываются даже не на той машине, на которой были брошены (сейчас клиент-серверных распределённых приложений больше, чем обычных, так что исключение, брошенное сервером, вполне может быть вынужден обрабатывать клиент) так что исключения желательно помечать атрибутом [Serializable], но пока я не рассказывал, что это такое (и, видимо, пока не буду), так что можно не заморачиваться. На самом деле, совсем идеологически правильное объявление своего исключения выглядит так:

\begin{minted}{csharp}
[Serializable]
public class MyException : Exception
{
    public MyException() { }
    public MyException(string message) : base(message) { }
    public MyException(string message, Exception inner) 
            : base(message, inner) { }
    protected MyException(
        System.Runtime.Serialization.SerializationInfo info,
        System.Runtime.Serialization.StreamingContext context)
        : base(info, context) { }
}
\end{minted}

Такую штуку Visual Studio сгенерит автоматически, если вы наберёте exc и дважды нажмёте Tab.

\section{Интересные библиотечные исключения}

В стандартной библиотеке есть несколько исключений, которые обрабатываются по-особенному и, если про них не знать, могут удивить. 

Самые интересные исключения называются Corrupted state exceptions (CSE) и интересны они тем, что не ловятся catch-ем. Они бросаются тогда, когда .NET-машина обнаружила, что находится в некорректном состоянии, поэтому, собственно, их особо нельзя ловить --- мы не можем доверять не только своему коду, но даже среде выполнения. Типичный пример такого исключения --- StackOverflowException, переполнение стека. Очень популярно среди прикладых программистов, и, пожалуй, самое неприятное исключение в реальной жизни, поскольку переполение стека не позволяет даже толком отследить, кто кого вызвал, чтобы привести систему в ошибочную ситуацию. Ещё к CSE относится AccessViolationException --- то, что в C++ встречалось на каждом шагу, попытка доступа к не выделенной программе памяти. Поскольку .NET-машина гарантирует корректность обращений к памяти, то AccessViolationException из кода чисто на .NET не добиться, надо что-то делать с указателями или вызывать нативный код. И понятно, почему его бесполезно ловить --- у нас может быть испорчена память программы. System.Runtime.InteropServices.SEHException --- это CSE, которое представляет в коде на .NET сразу несколько исключений, бросаемых операционнной системой и нативным кодом, которые тоже свидетельствуют о том, что всё очень плохо. В принципе, все эти исключения можно поймать и обработать, если хорошо попросить .NET-машину, но это делать, как правило, не нужно, так что подробности смотрите в документации.

Исключения FileLoadException, BadImageFormatException, InvalidProgramException и т.д. интересны тем, что их .NET-машина бросает сама при попытке (неудачной) загрузить сборку в процессе работы программы. Например, вы вызываете метод класса из какой-то библиотеки, только в этот момент .NET пытается загрузить библиотеку в память (в .NET нет статической линковки, как в C++, всё разрешение внешних зависимостей проходит во время выполнения), и если загрузка по тем или иным причинам не удалась, бросается одно из этих исключений. Например, когда файла со сборкой вообще нет или там некорректный байт-код. Такие исключения могут быть брошены, вообще говоря, при каждом обращении к какому-то типу, так что ловить их и обрабатывать обычно нет особого смысла (если только в Main-е, чтобы сообщить об ошибке и попрощаться).

Ещё исключение, которое может произойти внезапно и без всяких видимых причин --- это ThreadAbortException. Кидается, когда другой поток говорит нашему потоку прерваться, при этом наш поток может заниматься своими делами и быть совершенно неготовым к тому, что его прервут. К счастью, мы пока не пишем многопоточные программы.

TypeInitializationException и TargetInvocationException кидаются, когда что-то пошло не так при инициализации класса или при вызове метода через механизм рефлексии. Они в свойстве InnerException содержат ``настоящее'' исключение, которое привело к фэйлу. Тоже могут появляться внезапно, но пока мы ничего такого с рефлексией не делаем, встретить их в домашках маловероятно.

OutOfMemoryException тоже может кидаться внезапно, при любом выделении памяти на куче (например, при конкатенации строк). Оно ловится, но, как правило, ловить его нет особого смысла.

Можно вообще кинуть не new КакойТоТамException, а null. Тогда .NET-машина сама бросит NullReferenceException.

Есть ещё метод Environment.FailFast --- это просьба .NET-машине аварийно завершить работу программы (что-то вроде функции terminate() в C). Очень полезная штука если вы поняли, что не можете корректно восстановиться после ошибки --- чем быстрее в этом случае программа будет остановлена, тем лучше. Например,

\begin{minted}{csharp}
try 
{
     // Делать что-то полезное
}
catch (OutOfMemoryException e) 
{
    Console.WriteLine("Закончилась память :(");
    Environment.FailFast(
        String.Format($"Out of Memory: {e.Message}"));
}
\end{minted}

\section{Исключения и тесты}

Любая нормальная библиотека юнит-тестирования умеет проверять в тесте, что исключение было брошено. Например, в MsTest это делается с помощью атрибута ExpectedException, например: 

\begin{minted}{csharp}
[TestMethod]
[ExpectedException(typeof(System.DivideByZeroException))]
public void DivideTest()
{
    DivisionClass target = new DivisionClass();
    int numerator = 4;
    int denominator = 0;
    int actual = target.Divide(numerator, denominator);
}
\end{minted}

Этот тест будет считаться успешно пройденным, если в ходе работы было брошено исключение типа System.DivideByZeroException (или любой его наследник), и, что важно, будет считаться не пройденным, если это исключение не было брошено (либо было брошено, но другое). Обратите внимание, что после кода, который должен по вашему мнению бросить исключение, никакого кода можно уже не писать, до него всё равно не дойдёт управление, если система работает корректно. И если в вашем тесте есть блоки try/catch, то, скорее всего, вы делаете что-то не так.

\section{Исключения, best practices}

Есть некоторые общие правила по поводу работы с исключениями, которые компилятор не проверяет, но любой нормальный программист должен про них знать и им следовать.

Самое важное из этих правил --- не бросать исключения без нужды. Исключения --- не альтернатива return и не средство манипуляции потоком управлнения программы, просто потому, что бросание исключения --- вычислительно дорогая операция. Если где-то в глубине рекурсивных вызовов может произойти что-то не ошибочное, но требующее возврата из рекурсии, тут лучше использовать коды возврата, как бы ни был велик соблазн использовать исключения, чтобы сразу свернуть весь стек до того места, которое вам нужно. Общее правило таково, что при нормальном исполнении, когда всё хорошо, исключения не должны бросаться вообще за всё время жизни программы.

Свои исключения следует наследовать от класса System.Exception, если нет более подходящего по смыслу библиотечного класса. Имеет смысл продумать заранее иерархию исключений, чтобы их удобно было ловить и обрабатывать.

Все бросаемые методом исклюючения стоит документировать. Это старательно делается в библиотеке .NET, и то же рекомендуется делать прикладным программистам, по крайней мере для методов, которыми будут пользоваться другие люди (например, если вы сами пишете библиотеку). Для чего --- чтобы они хотя бы знали, что им надо ловить.

Нельзя ловить исключения как класс Exception, потому что это поймает их все, в том числе и NullReferenceException и прочие штуки, указывающие на ошибку кодирования. Единственное разумное исключение из этого правила --- ловить их в методе Main, логировать и завершать работу программы. Продолжать работу, если произошло что-то реально неожиданное, нельзя --- система находится в некорректном состоянии и там может происходить что угодно, в том числе порча пользовательских данных. По этой же причине нельзя ловить SystemException и тех его наследников, которые указывают на ошибку в коде, потому что как можно восстановиться после ошибки, если мы собственному коду не можем доверять? Лучше дать программе упасть. Например, catch (NullReferenceException) всегдда неправильно, потому что всегда, где null --- возможное значение ссылочной переменной, на это можно и нужно явно проверить, а не надеяться на исключение и его обработку. Просто потому, что вы думаете, что исключение произошло по одной причине, а оно произошло совершенно по другой.

По возможности выбирайте библиотечное исключение, которое вам подходит. Например, хорошими кандидатами будут InvalidOperationException для ситуации, когда класс находится в таком состоянии, когда не может выполнить запрос (например, попытка достать значение из пустого стека). Или ArgumentException, когда переданный аргумент некорректен (например, факториал от отрицательного числа). Чем больше таких проверок в программе, тем лучше, а если ваш метод будут вызывать из чужого кода (например, он часть публичного API вашей библиотеки), такие проверки вообще обязательны.

По стайлгайду имя любого класса-исключения должно заканчиваться на Exception.

При написании кода надо помнить, что бывают исключения, и заботиться об освобождении ресурсов, даже если исключение было брошено. Если вспомним про ``интересные'' исключения, то окажется, что это требование почти невыполнимо, ведь исключение может броситься всегда и возникает соблазн вообще весь код писать внутри try/finally. К счастью, есть языковые конструкции, которые сами просят компилятор сгенерировать finally, поэтому гарантируют освобождение ресурса.

Самая известная такая конструкция --- это блок using. Класс может задекларировать, что управляет ресурсами, которые надо освободить, реализовав библиотечный интерфейс IDisposable. В этом интерфейсе есть всего один метод Dispose(), который и должен освободить ресурсы. Это самое близкое в C\#, что есть к понятию ``деструктор'' из C++ (на самом деле, в C\# тоже есть деструкторы, но они тесно связаны с Dispose() и главное, пользоваться ими надо с большой осторожностью). using позволяет определить одну или несколько переменных, для которых гарантированно будет вызван Dispose(), как только они выйдут из области видимости:

\begin{minted}{csharp}
public static class Program 
{
    public static void Main() 
    {
        // Create the bytes to write to the temporary file.
        var bytesToWrite = new Byte[] { 1, 2, 3, 4, 5 };
        // Create the temporary file.
        using (var fs = new FileStream("Temp.dat", FileMode.Create)) 
        {
            // Write the bytes to the temporary file.
            fs.Write(bytesToWrite, 0, bytesToWrite.Length);
        }
        // Delete the temporary file.
        File.Delete("Temp.dat");
    }
}
\end{minted}

Как видим, это особенно полезно при работе с файлами --- мы внутри заголовка using открываем поток ввода-вывода в файл, работаем с ним, а using позаботится о вызове метода Dispose(), который закроет файл. Вся работа с подобного рода ресурсами должна быть через using.

\section{Особенности современного C\#}

\subsection{C\# 7 и старее}

Дальше будет не относящаяся к теме исключений демонстрация разных возможностей языка, про которые неплохо бы знать любому C\#-программисту. Первая такая возможность --- кортежи и работа с кортежами, которая есть в любом нормальном функциональном языке (в том числе F\#), и которой, видимо, уже никогда не будет в Java. Кортеж --- это пара, тройка и т.д. значений, потенциально разного типа, на уровне библиотеки они были в языке очень давно (класс Tuple), с .NET 4.7 и C\# 7.0 появилась их удобная синтаксическая поддержка и, в отличие от класса Tuple, кортежи стали типами-значениями, что существенно улучшило их в плане скорости работы и нагрузки на кучу. Вот так это примерно выглядит:

\begin{minted}{csharp}
static (int prev, int cur) Fibonacci(int n)
{
    var (prevPrev, prev) = n <= 2 ? (0, 1) : Fibonacci(n - 1);
    return (prev, prevPrev + prev);
}

private static void Main(string[] args)
{
    var (_, result) = Fibonacci(7);
    Console.WriteLine(result);
}
\end{minted}

В принципе, писать имена полей не обязательно, тогда к ним всё равно будет доступ через деконструкцию (то, что в примере происходит в Main, разбор кортежа по элементам), или через свойства Item1, Item2 и т.д. кортежа. Но если имена полей написать, то можно работать с кортежем как со структурой, не Item1 и Item2, а prev и cur, что гораздо более читаемо. Можно указывать имена явно или доверить компилятору их назвать по используемым для их определения переменным:

\begin{minted}{csharp}
int count = 5;
string label = "Colors used in the map";
var pair = (count: count, label: label);

int count = 5;
string label = "Colors used in the map";
var pair = (count, label); // Имена элементов тут будут "count" и "label"
\end{minted}

Ещё, про свойства тут уже рассказывалось, но что можно было пропустить --- то, что автоматические свойства можно инициализировать прямо в месте объявления, как поля:

\begin{minted}{csharp}
public class Person
{
    public int Age { get; set; } = 0;
    public string Name { get; set; } = "Anonymous";
}
\end{minted}

Ещё автоматические свойства, у которых есть только геттер, на самом деле могут быть инициализированы в месте объявления или в конструкторе, прямо как readonly-поля.

Следующая интересная фича --- это операторы для работы с null-значениями. Во-первых, условный null-оператор:

\begin{minted}{csharp}
var first = person?.FirstName;

int? age = person?.Age;
if (age.HasValue)
{
    int realAge = age.Value;
}
\end{minted}

Он работает так: если слева от него не null, он выполняет разыменование и возвращает значение свойства, если слева null, то возвращает null. Интересно, что эти операторы работают и в цепочке: person?.FirstName?.Item(0) или что-нибудь в таком духе вполне будет работать. Это хорошо и понятно для ссылочных типов, но для типов-значений null не является корректным значением, поэтому просто написать int age = person?.Age; нельзя, а вдруг null будет. Поэтому есть ещё nullable-типы int?, double? и т.д. На самом деле это структуры (то есть типы-значения), которые хранят в себе значение, если оно есть, и знают, если его нет. Их можно спросить свойствами HasValue и Value.

Есть ещё оператор ??, он возвращает значение слева, если оно не null, а иначе значение справа. Почти как тернарный оператор ... ? ... : ..., но для null-ов. Этакий хороший способ указать значение по умолчанию:

\begin{minted}{csharp}
var otherFirst = person?.FirstName ?? "Unspecified";
\end{minted}

Ещё одна относительно недавно добавленная в язык возможность --- объявление локальных функций внутри метода:

\begin{minted}{csharp}
public int Fibonacci(int x)
{
    if (x < 0) 
        throw new ArgumentException("Less negativity please!", nameof(x));
    return Fib(x).current;

    (int current, int previous) Fib(int i)
    {
        if (i == 0) return (1, 0);
        var (p, pp) = Fib(i - 1);
        return (p + pp, p);
    }
}
\end{minted}

Это чтобы кучу private-методов не разводить, все необходимые вспомогательные штуки упакованы внутрь метода и снаружи не видны.

В .NET бывают свойства, принимающие параметры, самый известный пример таких свойств --- это свойство Item или индексовое свойство. Объявляется оно, например, так: 

\begin{minted}{csharp}
class SampleCollection {
    private int[] arr = new int[100];
    public int this[int i]
    {
        get
        {
            return arr[i];
        }
        set
        {
            arr[i] = value;
        }
    }
}
\end{minted}

Потом можно коллекцию, в котором есть такое свойство, использовать как массив,

\begin{minted}{csharp}
var collection = new SampleCollection();
collection[1] = 10;
\end{minted}

Естественно, у класса может быть только один индексер.

Есть и вот такой довольно странный способ инициализации коллекции, у которой есть индексер:

\begin{minted}{csharp}
private Dictionary<int, string> webErrors = new Dictionary<int, string>
{
    [404] = "Page not Found",
    [302] = "Page moved, but left a forwarding address.",
    [500] = "The web server can't come out to play today."
};
\end{minted}

Ещё пара особенностей, касающихся передачи аргументов в методы. Необязательные аргументы были и в C++, поэтому удивлять не должны, а вто именованные аргументы в современных языках довольно редки (хотя и были в Аде):

\begin{minted}{csharp}
PrintOrderDetails(productName: "Red Mug", 31, "Gift Shop");

public void ExampleMethod(int required, 
    string optionalstr = "default string",
    int optionalint = 10)

anExample.ExampleMethod(3, optionalint: 4);
\end{minted}

Для чего необязательные аргументы, я думаю, понятно, хотя использовать их особо не рекомендуется, значение по умолчанию может быть неожиданно для вызывающего, и вообще, плохо, когда что-то происходит само по себе. Имеенованные аргументы же полезны, если есть опасность перепутать порядок параметров и хочется повысить читабельность кода в месте вызова. Хотя используются они нынче довольно редко.

А вот методы с переменным числом параметров используются довольно часто. Выглядит это так:

\begin{minted}{csharp}
public static void UseParams(params int[] list)
{
    for (int i = 0; i < list.Length; i++)
    {
        Console.Write(list[i] + " ");
    }
    Console.WriteLine();
}
...
UseParams(1, 2, 3, 4);
\end{minted}

Ключевое слово params говорит, что метод может принимать параметры через запятую, и они должны складываться в массив, объявленный с params. Аргументов у метода может быть много, но параметр с params должен быть один и он должен быть объявлен в самом конце. Так, например, работает Console.WriteLine, которым все пользовались.

\subsection{C\# 8}

В C\# 8 появилось много приятного синтаксического сахара (что по моему мнению неоправданно усложнило язык, зато ещё приблизило синтаксис C\# к современным функционаольно-объектно-ориентированным языкам, в частности, F\#). Первый --- это switch-выражение.

Сравните

\begin{minted}{csharp}
public static RgbColor FromRainbow(Rainbow colorBand)
{ 
    switch (colorBand)
    {
        case Rainbow.Red: 
            return new RGBColor(0xFF, 0x00, 0x00);
        case Rainbow.Orange => 
            return new RGBColor(0xFF, 0x7F, 0x00);
        case Rainbow.Yellow => 
            return new RGBColor(0xFF, 0xFF, 0x00);
        case Rainbow.Blue => 
            return new RGBColor(0x00, 0x00, 0xFF);
        case Rainbow.Indigo => 
            return new RGBColor(0x4B, 0x00, 0x82);
        case Rainbow.Violet => 
            return new RGBColor(0x94, 0x00, 0xD3);
        default:
            throw new ArgumentException(
                message: "invalid enum value",
                paramName: nameof(colorBand));
    };
}
\end{minted}

И

\begin{minted}{csharp}
public static RGBColor FromRainbow(Rainbow colorBand) =>
    colorBand switch
    {
        Rainbow.Red    => new RGBColor(0xFF, 0x00, 0x00),
        Rainbow.Orange => new RGBColor(0xFF, 0x7F, 0x00),
        Rainbow.Yellow => new RGBColor(0xFF, 0xFF, 0x00),
        Rainbow.Blue   => new RGBColor(0x00, 0x00, 0xFF),
        Rainbow.Indigo => new RGBColor(0x4B, 0x00, 0x82),
        Rainbow.Violet => new RGBColor(0x94, 0x00, 0xD3),
        _ => throw new ArgumentException(
                message: "invalid enum value", 
                paramName: nameof(colorBand)),
    };
\end{minted}

Второй вариант в полтора раза короче сам по себе, но его главное достоинство в том, что обычный switch --- это оператор, так что внутри тела case-оы надо писать тоже операторы (например, return) и его нельзя использовать в выражениях. Switch expression --- это именно выражение, так что может использоваться в других выражениях (этакое обобщение тернарного оператора). Все ветки должны возвращать выражение одного типа (или кидать исключение), никаких case и return писать не надо. На самом деле, это давно известный и любимый в функциональных языках (в частности, в F\#) оператор match, просто его переименовали в switch, чтобы хомячкам было привычней.

Как и в функциональных языках, слева от => может стоять не просто какое-то значение, а \textit{шаблон}, что позволяет делать довольно интересные вещи. Например, switch по значению какого-нибудь свойства:

\begin{minted}{csharp}
public static decimal ComputeSalesTax(Address location, decimal salePrice) =>
    location switch
    {
        { State: "WA" } => salePrice * 0.06M,
        { State: "MN" } => salePrice * 0.75M,
        { State: "MI" } => salePrice * 0.05M,
        // ...
        _ => 0M
    };
\end{minted}

Или даже по кортежу:

\begin{minted}{csharp}
public static string RockPaperScissors(string first, string second)
    => (first, second) switch
    {
        ("rock", "paper") => "rock is covered by paper. Paper wins.",
        ("rock", "scissors") => "rock breaks scissors. Rock wins.",
        ("paper", "rock") => "paper covers rock. Paper wins.",
        ("paper", "scissors") => "paper is cut by scissors. Scissors wins.",
        ("scissors", "rock") => "scissors is broken by rock. Rock wins.",
        ("scissors", "paper") => "scissors cuts paper. Scissors wins.",
        (_, _) => "tie"
    };
\end{minted}

Как видим, кортеж мы собираем прямо тут, но могли бы и принимать сразу пару. А потом в каждом из случаев switch-а мы разбираем кортеж по составным частям и сравниваем с константами. <<\_>>, как обычно, означает <<не важно>>, матчится со всем и никуда не присваивает поматченное значение.

На самом деле, шаблоны можно использовать и при объявлении переменных:

\begin{minted}{csharp}
    var (x, y) = (1, 2);
\end{minted}

И даже управлять для произвольных типов, как значение этого типа разбирается шаблонами:

\begin{minted}{csharp}
public class Point
{
    public int X { get; }
    public int Y { get; }

    public Point(int x, int y) => (X, Y) = (x, y);

    public void Deconstruct(out int x, out int y) =>
        (x, y) = (X, Y);
}
\end{minted}

Теперь можно писать

\begin{minted}{csharp}
var point = new Point(10, 20);
var (a, b) = point;
\end{minted}

Метод Deconstruct с out-параметрами ищется компилятором по имени, и если у типа он есть (и с подходящим числом параметров), используется при сопоставлении шаблонов (out-параметры, видимо, чтобы избежать коллизий с <<нормальными>> методами, которые просто называются Deconstruct --- нормальные методы возвращали бы кортеж).

Деконструкция, естественно, работает и в expression switch, и можно даже давать имена частям шаблона, чтобы потом их использовать после стрелки:

\begin{minted}{csharp}
static string Quadrant(Point p) => p switch
{
    (0, 0) => "origin",
    (var x, var y) when x > 0 && y > 0 => "Quadrant 1",
    (var x, var y) when x < 0 && y > 0 => "Quadrant 2",
    (var x, var y) when x < 0 && y < 0 => "Quadrant 3",
    (var x, var y) when x > 0 && y < 0 => "Quadrant 4",
    (var x, var y) => "on a border",
    _ => "unknown"
};
\end{minted}

Опять-таки, прямо как в F\#, но если вы никогда не программировали на F\# (не удивлюсь), просто будьте в курсе, что это не какие-то новые крутые фичи, это просто постепенное перетаскивание в C\# синтаксиса и языковых особенностей более продвинутых с теоретической точки зрения <<языков-родственников>>.

Ещё одна штука, которая была в F\# сколько себя помню, и появилась в C\# 8 --- using var, синтаксический сахар, чтобы не писать using (var ...) и фигурные скобки. Вот так это выглядит:

\begin{minted}{csharp}
static void WriteLinesToFile(IEnumerable<string> lines)
{
    using var file = new System.IO.StreamWriter("WriteLines2.txt");
    foreach (string line in lines)
    {
        // If the line doesn't contain the word 'Second', 
        // write the line to the file.
        if (!line.Contains("Second"))
        {
            file.WriteLine(line);
        }
    }
// file is disposed here
}
\end{minted}

Это то же самое, что и

\begin{minted}{csharp}
static void WriteLinesToFile(IEnumerable<string> lines)
{
    using (var file = new System.IO.StreamWriter("WriteLines2.txt")) 
    {
        foreach (string line in lines)
        {
            // If the line doesn't contain the word 'Second', 
            // write the line to the file.
            if (!line.Contains("Second"))
            {
                file.WriteLine(line);
            }
        }
    }
// file is disposed here
}
\end{minted}

Особенно хорошо, когда у вас несколько файлов, которыре надо открыть одновременно (в старом синтаксисе код бы сполз вправо). Но опасайтесь, если вам надо закрыть файл в какой-то определённый момент (например, вы закончили в него писать, закрыли и хотите начать читать), using var может не подойти (он закроет файл только в конце функции).

А вот Nullable reference-типы, поддержка которых появилась в C\# 8, это не синтаксический сахар, а реально крутая новая фича языка (ну как, в F\# оно встроено в язык с самого начала...). Можно сказать компилятору, что ни одна ссылочная переменная не может иметь значение null. Зачем? Как говорил Tony Hoare (автор кусорта и значительного куска теории параллельных вычислений), изобретение null был его ошибкой, стоившей миллиарды долларов. Без nullability-анализа \textbf{любая} ссылочная переменная могла иметь значение null, поэтому формально при \textbf{каждом} разыменовании (будь то обращение к полю, вызов метода и т.п.) мы должны быть уверены, что переменная не null. Однако так, конечно, никто не делал, потэтому в любой сколько-нибудь сложной программе всегда есть куча багов, приводящих к Null Reference/Pointer Exception.

Nullability-анализ во время компиляции пытается доказать про каждую ссылочную переменную, что она не null. Например, запрещает явное присвоение null, запрещает использование неинициализированной ссылочной переменной, запрещает присвоение ссылочной переменной значения, которое каким-то образом может быть null. Как с этим жить, если даже чтобы реализовать список, обязательно нужен null, которому было бы равно свойство Next последнего элемента? Некоторые переменные помечаются как nullable --- им можно иметь значение null, в таком случае они ведут себя как обычно, но в не-nullable-переменную их так просто не присвоить. И выполнять разыменование таких переменных можно только явно сказав, что вы знаете, что делаете. 

Например, \mintinline{csharp}{string name;} --- это не nullable-переменная, использование её без инициализации или \mintinline{csharp}{name = null;} вызовет ошибку компиляции. 

\mintinline{csharp}{string? name;} --- это nullable-переменная, она может быть null, так что \mintinline{csharp}{name = null;} писать можно, но теперь \mintinline{csharp}{name.Length} вызовет ошибку компиляции (мы не можем доказать, что вправе обратиться к свойству). Если мы знаем, что делаем, мы можем использовать <<null-forgiving operator>>, <<!.>>: \mintinline{csharp}{name!.Length;} работать будет. На самом деле, если все переменные сделать nullable и всегда использовать !., всё будет работать по-старому, но зачем.

Интересно, что по умолчанию nullability-анализ выключен и его даже нельзя включить через GUI Visual Studio. Почему --- почти весь существующий код был написан до появления nullability-анализа, так что если его просто взять и включить, всё перестанет компилироваться. И вряд ли кто-то захочет быстренько зарефакторить пару миллионов строк кода, чтобы расставить там nullable-типы и null-forgiving-операторы. Поэтому, чтобы включить поддержку nullability-анализа для проекта, надо в проектный файл дописать

\begin{minted}{xml}
<Nullable>enable</Nullable>
\end{minted}

Например,

\begin{minted}{xml}
<Project Sdk="Microsoft.NET.Sdk">

<PropertyGroup>
  <OutputType>Exe</OutputType>
  <TargetFramework>net5.0</TargetFramework>
  <Nullable>enable</Nullable>
</PropertyGroup>

</Project>
\end{minted}

Анализом можно управлять и пофайлово, и включать-выключать его по месту, директивами \mintinline{csharp}{#nullable disable} и \mintinline{csharp}{#nullable enable}. Однако учтите, что не null-овость ссылочной переменной во всех случаях доказать во время компиляции невозможно теоретически, так что исключения, связанные с разыменованием нулевого указателя, всё-таки возможны, но вероятность их существенно меньше.

Вообще, можно утверждать, что любой современный код должен использовать nullability-анализ, чтобы Хоар в конце концов мог быть прощён за свою ошибку. Поэтому вот подробности про nullability в C\#: \url{https://docs.microsoft.com/en-us/dotnet/csharp/nullable-references}, и начиная с этой пары она должна быть обязательно включена во всех новых домашках.

\subsection{C\# 9}

Самую интересную фичу C\# 9 мы уже видели аж на первой паре --- это top-level statement-ы, возможность писать программу без всякого boilerplate-кода типа объявления классов. Это сделано для того, чтобы на C\# можно было легко писать небольшие программы и скрипты, и проще было учиться (и был хоть какой-то шанс против засилья Питона для решения небольших задач). Для сколько-нибудь больших проектов это ничего не даёт, впрочем.

Остальные изменения направлены на то, чтобы улучшить уже существующие фичи и сделать язык более консистентным (как внутри, так и более согласованным с F\#, как обычно). Во-первых, несколько улучшен синтаксис сопоставления шаблонов, теперь это целый полноценный подъязык:

\begin{minted}{csharp}
public static bool IsLetterOrSeparator(char c) =>
    c is (>= 'a' and <= 'z') or (>= 'A' and <= 'Z') or '.' or ',';
\end{minted}

Чаще всего, однако, это используется в простых шаблонах, например, \mintinline{csharp}{if (e is not null) ...}. Так более человечно, чем всякие !=.

Что ещё стало приятнее, это продвинутый локальный вывод типов. Теперь можно использовать не только var, но и не писать явно тип справа от присваивания, если понятно, о чём идёт речь. Сравните:

\begin{minted}{csharp}
    private List<WeatherObservation> observations = new List<WeatherObservation>();
\end{minted}

Тут var вам ничем не поможет, потому что var нельзя использовать при объявлении полей. Поможет C\# 9, где можно писать вот так:

\begin{minted}{csharp}
    private List<WeatherObservation> observations = new();
\end{minted}

Тип может быть понятен не только при объявлении поля, но и при вызове метода, так что можно писать так:

\begin{minted}{csharp}
public WeatherForecast ForecastFor(
        DateTime forecastDate, WeatherForecastOptions options)
...
var forecast = station.ForecastFor(DateTime.Now.AddDays(2), new());
\end{minted}


Ещё это хорошо работает с init-only-свойствами, ещё одной новой фичей C\# 9. init-only свойство --- это свойство, из которого можно только читать, кроме момента создания объекта, объявляется так:

\begin{minted}{csharp}
public struct WeatherObservation
{
    public DateTime RecordedAt { get; init; }
    public decimal TemperatureInCelsius { get; init; }
    public decimal PressureInMillibars { get; init; }

    public override string ToString() =>
        $"At {RecordedAt:h:mm tt} on {RecordedAt:M/d/yyyy}: " +
        $"Temp = {TemperatureInCelsius}, with {PressureInMillibars} pressure";
}
\end{minted}

Обратите внимание на init; вместо set;. Такие свойства можно использовать в синтаксисе инициализации так:

\begin{minted}{csharp}
WeatherStation station = new() { Location = "Seattle, WA" };
\end{minted}

Дальше поменять значение такого свойства будет нельзя (что хорошо и правильно, всё, что может не меняться, должно быть немутабельным, const ваш лучший друг).

Ну и последняя штука, которую обычно ставят на первое место по значимости, это record-ы. Record --- это по сути ссылочная структура, либо же класс, который ведёт себя как структура с точки зрения оператора сравнения и хеш-кода. Кроме того, record-ы неизменяемы. Объявляются так:

\begin{minted}{csharp}
public record Person
{
    public string LastName { get; }
    public string FirstName { get; }

    public Person(string first, string last) 
        => (FirstName, LastName) = (first, last);
}
\end{minted}

Это буквально record-ы из F\#, причём там они были такими изначально и F\# долгое время вообще не поддерживал C\#-овые структуры, что создавало массу неудобств при написании <<кроссязыковых>> приложений и интеграции (да-да, писать половину кода программы на C\# и половину на F\# вполне нормально). Сначала в F\# добавили struct record-ы (то есть record-ы, но размещаемые на стеке, как в C\# struct-ы), а затем, через три года, и в C\# добавили F\#-овые record-ы.

Зачем они нужны в обычном коде --- как обычно, чтобы компилятор гарантировал немутабельность, что всегда приятно. Ну и для оптимизации --- если вы хотите семантику передачи по значению, но структура просто физически большая по размеру (не знаю, 150 полей типа Int64), передавать её повсюду как struct заставит постоянно копировать данные на стеке вызовов, что медленно. При передаче record-а по ссылке копируется только указатель, всего 8 байт.

\end{document}

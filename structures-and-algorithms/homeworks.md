# Домашние работы по кусу "Функциональное программирование на языке F#"
**Дедлайны по всем задачам** — две недели, если явно не написано иного

## Домашняя работа 1. Функциональное программирование на языке F#. Введение

### Задача 1. Факториал
**Баллов** — 1

Посчитать факториал.

### Задача 2. Фибоначчи
**Баллов** — 1

Посчитать числа Фибоначчи (за линейное время).

### Задача 3. Обращение списка
**Баллов** — 1

Реализовать функцию обращения списка (за линейное время).

### Задача 4. Ряд степеней
**Баллов** — 1

Реализовать функцию, которая принимает на вход `n` и `m` и возвращает список из элементов `[2^n; 2^(n + 1); ...; 2^(n + m)]`. Подумайте, как минимизировать число возведений в степень.

### Задача 5. Поиск числа
**Баллов** — 1

Реализовать функцию, которая выдаёт первую позицию вхождения заданного числа в список. Подумайте, что идеологически правильно делать, если элемента в списке нет.

## Домашняя работа 2. Продолжение про F\#

Во всех задачах нужны юнит-тесты.

### Задача 1. Чётные числа
**Баллов** — 1

Реализовать три варианта функции, подсчитывающей количество чётных чисел в списке (с использованием стандартных функций map, filter, fold). Использование рекурсии не допускается, зато нужен FsCheck для проверки функций на эквивалентность. 

### Задача 2. Map для деревьев
**Баллов** — 1

Реализовать функцию, применяющую функцию к каждому элементу двоичного дерева и возвращающую новое двоичное дерево, каждый элемент которого — результат применения функции к соответствующему элементу исходного дерева (map для деревьев).

### Задача 3. Дерево разбора
**Баллов** — 1

Посчитать значение дерева разбора арифметического выражения, заданного через вложенные discriminated union-ы.

### Задача 4. Простые числа
**Баллов** — 1

Реализовать функцию, генерирующую бесконечную последовательность простых чисел.

## Домашняя работа 3. Лямбда-исчисление

### Задача 1. Нормализация
**Баллов** — 1

Привести к нормальной форме λ-терм `((λa.(λb.b b) (λb.b b)) b) ((λc.(c b)) (λa.a))`. Решение (в виде последовательности преобразований) набрать в TeX и выложить файл .tex на GitHub. Может помочь www.overleaf.com. Каждое преобразование должно быть одним действием (не пропускайте преобразования в описании вывода).

### Задача 2. S K K
**Баллов** — 1

Доказать, что S K K = I. Доказательство набрать в TeX и выложить на GitHub. Делать надо самостоятельно, это известное (и несложное) упражнение, так что гуглить нечестно.

### Задача 3. Лямбда-интерпретатор
**Баллов** — 3

Реализовать интерпретатор лямбда-выражений, выполняющий бета-редукцию по нормальной стратегии. Лямбда-выражения задаются через размеченные объединения. Должна поддерживаться альфа-конверсия для избежания захвата свободных переменных. 

Примечание: если не извращаться и делать всё по определениям, задача простая.

## Домашняя работа 4. Типы и генерики в F\#

### Задача 1. Скобочная последовательность
**Баллов** — 2

Реализовать функцию, которая по произвольной строке проверяет корректность скобочной последовательности в этой строке. Скобки бывают трёх видов. Подумайте, как минимизировать копипаст.

### Задача 2. Point-free
**Баллов** — 2

Записать в point-free стиле `func x l = List.map (fun y -> y * x) l`. Выписать шаги вывода и проверить с помощью FsCheck корректность результата.

### Задача 3. Телефонный справочник
**Баллов** — 2

Написать программу — телефонный справочник. Она должна уметь хранить имена и номера телефонов, в интерактивном режиме осуществлять следующие операции:

- выйти;
- добавить запись (имя и телефон);
- найти телефон по имени;
- найти имя по телефону;
- вывести всё текущее содержимое базы;
- сохранить текущие данные в файл;
- считать данные из файла. 

При этом бизнес-логика должна быть отделена от пользовательского интерфейса и покрыта тестами.

Пользоваться мутабельным состоянием для этой задачи всё ещё нельзя.

## Домашняя работа 5. Объектно-ориентированное программирование в F\#

### Задача 1. Локальная сеть
**Баллов** — 3

В объектно-ориентированном стиле смоделировать работу локальной сети:

- в сети есть несколько компьютеров, связанных друг с другом (каким образом — можно задавать, например, матрицей смежности);
- на каждом компе стоит ОС (Windows, Linux, etc...);
- в сети гуляют вирусы, так что для каждой машины есть вероятность заразиться (вероятность зависит от типа ОС), заражаются компьютеры, непосредственно соединённые с заражёнными;
- заражения (и проверки, заразился компьютер или нет) происходят дискретно — по ходам;
  - обратите внимание, если компьютер A связан с B, а B связан с C, то A не может заразить C за один ход.

Требуется выводить состояние сети после каждого хода, пока состояние в принципе может измениться.

Необходимы также юнит-тесты, проверяющие корректность работы алгоритма заражения: если вероятность заражения всегда 1, вирус должен вести себя как обход в ширину, если вероятность 0 — никто не должен заражаться. Необходимо использовать mock-объекты для тестирования (подумайте, куда их можно прикрутить — например, для исключения фактора случайности из симуляции).

## Домашняя работа 6. Вычислительные выражения в F\# 

### Задача 1. Округляющий Workflow.
**Баллов** — 1

Реализовать Workflow, выполняющий математические вычисления с заданной (как аргумент Builder-а) точностью. Например,

```
rounding 3 {
    let! a = 2.0 / 12.0
    let! b = 3.5
    return a / b
}
```

должно возвращать 0.048

### Задача 2. Вычисления над строками.
**Баллов** — 1

Реализовать Workflow, выполняющий вычисления с числами, заданными в виде строк. Например,

```
let result = calculate {
        let! x = "1"
        let! y = "2"
        let z = x + y
        return z
    }
```

должно возвращать значение, содержащее 3, тогда как

```
let result = calculate {
        let! x = "1"
        let! y = "Ъ"
        let z = x + y
        return z
    }
```

должно возвращать значение, указывающее на отсутствие результата.

Задачи простые, так что можно сдавать в одном проекте (только не забудьте про тесты)

## Домашняя работа 7. Многопоточное программирование в F\#

### Задача 1. Lazy
**Баллов** — 3

Переделать на F# задачу Lazy из предыдущего семестра (с некоторой дополнительной функциональностью), то есть реализовать интерфейс, представляющий ленивое вычисление:

```
type ILazy<'a> =
    abstract member Get: unit -> 'a
```

Объект Lazy создаётся на основе вычисления (представляемого лямбда-функцией `supplier : unit -> 'a`).

- Первый вызов `Get()` вызывает вычисление и возвращает результат.
- Повторные вызовы `Get()` возвращают тот же объект, что и первый вызов.
- В однопоточном режиме вычисление должно запускаться не более одного раза, в многопоточном — как получится (см. далее).

Должно быть сделано три разные реализации `Lazy<'a>`:

- простая версия с гарантией корректной работы в однопоточном режиме (без синхронизации);
- гарантия корректной работы в многопоточном режиме; вычисление не должно производиться более одного раза (что-то наподобие многопоточного синглтона, без лишних блокировок);
- то же, что и предыдущее, но lock-free; вычисление может производиться более одного раза, но при этом `Lazy.Get` всегда должен возвращать один и тот же объект (то есть результаты «лишних» вычислений должны теряться).

Разумеется, нужны модульные тесты, при этом надо избежать копипаста.

### Задача 2. Мини-краулер
**Баллов** — 2

Написать функцию, принимающую адрес веб-страницы, скачивающую все веб-страницы, на которые есть ссылки с указанной, и печатающую информацию о размере каждой в формате "адрес страницы — число символов". Ссылки нужно обрабатывать только заданные в форме `<a href="http://...">`. Для поиска ссылок на странице могут быть полезны регулярные выражения (класс `System.Text.RegularExpressions.Regex`). Качать страницы надо параллельно.

## Домашняя работа 8. Синтаксический анализ на F\#, часть 1

### Задача 1. Продвинутый лямбда-интерпретатор, грамматика
**Баллов** — 2

Разработать синтаксический анализатор для интерпретатора лямбда-выражений из домашней работы 3, с дополнительной функциональностью: возможностью именовать лямбда-выражения. Интерпретатор должен принимать на вход строку или файл (должно поддерживаться и то и другое) с набором именованных определений и лямбда-выражением, в котором именованные определения используются. Должно выдаваться в виде строки лямбда-выражение, полученное бета-редукцией входного лямбда-выражения. Лямбда во входных данных обозначается символом \, именованное определение начинается с let и может быть только одно на строке. let можно считать ключевым словом, то есть запретить так именовать переменные. Должны поддерживаться лямбда-абстракции с несколькими «параметрами». 

Пример:

```
let S = \x y z.x z (y z)

let K = \x y.x

S K K
```

Должно получиться в качестве ответа:

```
\x.x
```

(или любой другой терм, альфа-эквивалентный этому).

Грамматика, естественно, получится леворекурсивная (`аппликация ::= терм терм`, но `терм := аппликация | лямбда-абстракция | переменная | (терм)`), требуется факторизация. Более того, даже аппликацию от переменной без факторизации не отличить.

Первой задачей будет написать факторизованную однозначную грамматику без эпсилон-переходов для данного языка. Сдавать в виде .tex-документа (с собранным .pdf), закоммиченного в репозиторий с домашками. Также приложите пару примеров вывода в данной грамматике.

Через неделю появится задача, требующая реализовать этот парсер на FParsec.

## Домашняя работа 9. Синтаксический анализ на F\#, часть 2

### Задача 1. Продвинутый лямбда-интерпретатор, реализация
**Баллов** — 3

Реализовать на FParsec парсер лямбда-выражений по требованиям из предыдущей домашней работы.

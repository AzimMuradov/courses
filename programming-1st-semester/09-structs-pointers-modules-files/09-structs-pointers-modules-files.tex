\documentclass[xetex,mathserif,serif]{beamer}
\usepackage{polyglossia}
\setdefaultlanguage[babelshorthands=true]{russian}
\usepackage{minted}
\usepackage{tabu}
\usepackage{pgfplots}
\usepackage{textpos}

\useoutertheme{infolines}

\usepackage{fontspec}
\setmainfont{FreeSans}
\newfontfamily{\russianfonttt}{FreeSans}

\usepackage{forest}
\usetikzlibrary{arrows}

\tabulinesep=0.7mm

\title{Структуры, указатели, модули, файлы}
\author[Юрий Литвинов]{Юрий Литвинов \newline \textcolor{gray}{\small\texttt{yurii.litvinov@gmail.com}}}

\date{05.10.2018}

\begin{document}
	
	\frame{\titlepage}
	
	\begin{frame}
		\frametitle{Структуры}
		\begin{itemize}
			\item Способ группировки родственных по смыслу значений
			\item Структура --- это тип
			\begin{itemize}
				\item В памяти представляется как поля, лежащие друг за другом, возможно, с ``дырками'' (padding)
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Указатели и ссылки}
		\begin{itemize}
			\item Указатель --- адрес ячейки в памяти
			\item Ссылка --- ``синоним'', просто другое название для ячейки в памяти
			\begin{itemize}
				\item Можно считать, что ссылка --- это указатель, который не надо разыменовывать (и нельзя менять)
			\end{itemize}
			\item Структуры и указатели настолько часто используются вместе, что есть оператор -> (разыменовать указатель на структуру и обратиться к её полю)
			\begin{itemize}
				\item 
				\begin{footnotesize}
					\begin{minted}{cpp}
Point *p = new Point { 10, 20 };
printf("(%d, %d)", p->x, p->y);
					\end{minted}
					Или
					\begin{minted}{cpp}
auto p = new Point { 10, 20 };
printf("(%d, %d)", p->x, p->y);
					\end{minted}
				\end{footnotesize}
				\item То же самое, что \mintinline{cpp}|(*p).x| и \mintinline{cpp}|(*p).y|
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Файлы}
		\begin{itemize}
			\item Последовательность байтов на диске
			\begin{itemize}
				\item Бывают ``сырые'' и ``текстовые''
				\begin{itemize}
					\item Самому файлу всё равно, это лишь способы интерпретации его содержимого
				\end{itemize}
				\item Режимы доступа: r, w, a, r+, w+, a+
				\item Курсор
				\item EOF
			\end{itemize}
			\item Сишные функции
			\begin{itemize}
				\item fopen, fclose, fprintf, fscanf, fseek, ftell, fgets
			\end{itemize}
			\item Файлы надо не забывать закрывать
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Модули}
		\begin{itemize}
			\item Способ группировки кода в логически обособленные группы
			\item В C++ это реализуется с помощью заголовочных файлов и файлов с реализацией
			\begin{itemize}
				\item .h и .cpp
			\end{itemize}
			\item В отдельный модуль выносятся объявления типов данных и функции, которые делают одно дело
			\begin{itemize}
				\item Например, разные функции сортировки
				\item Или всё для работы с матрицами
			\end{itemize}
			\item В интерфейсную часть модуля выносится только то, что может использовать другой код
			\begin{itemize}
				\item Меньше знаешь --- крепче спишь
			\end{itemize}
			\item Функции, используемые только для реализации, пишутся только в .cpp-файле
			\begin{itemize}
				\item Например, функция разделения массива для быстрой сортировки или swap
			\end{itemize}
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Модули}
		\begin{scriptsize}
			Заголовочный файл:
			\begin{minted}{cpp}
#pragma once

// Комментарий к функции 1
int function1(int x, int y);

// Комментарий к функции 2
void function2();
			\end{minted}
			.cpp-файл:
			\begin{minted}{cpp}
#include <имя заголовочного файла.h>

#include <все остальные библиотеки>

int function1(int x, int y)
{
    ...
}

void function2()
{
    ...
}
			\end{minted}
		\end{scriptsize}
	\end{frame}

\end{document}

